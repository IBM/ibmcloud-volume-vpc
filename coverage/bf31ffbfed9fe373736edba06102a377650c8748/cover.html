
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibmcloud-volume-vpc/block/provider/attach_volume.go (100.0%)</option>
				
				<option value="file1">github.com/IBM/ibmcloud-volume-vpc/block/provider/authorize_volume.go (100.0%)</option>
				
				<option value="file2">github.com/IBM/ibmcloud-volume-vpc/block/provider/create_snapshot.go (95.6%)</option>
				
				<option value="file3">github.com/IBM/ibmcloud-volume-vpc/block/provider/create_volume.go (96.7%)</option>
				
				<option value="file4">github.com/IBM/ibmcloud-volume-vpc/block/provider/create_volume_from_snapshot.go (100.0%)</option>
				
				<option value="file5">github.com/IBM/ibmcloud-volume-vpc/block/provider/delete_snapshot.go (88.2%)</option>
				
				<option value="file6">github.com/IBM/ibmcloud-volume-vpc/block/provider/delete_volume.go (89.5%)</option>
				
				<option value="file7">github.com/IBM/ibmcloud-volume-vpc/block/provider/detach_volume.go (100.0%)</option>
				
				<option value="file8">github.com/IBM/ibmcloud-volume-vpc/block/provider/error.go (100.0%)</option>
				
				<option value="file9">github.com/IBM/ibmcloud-volume-vpc/block/provider/expand_volume.go (88.0%)</option>
				
				<option value="file10">github.com/IBM/ibmcloud-volume-vpc/block/provider/get_snapshot.go (97.1%)</option>
				
				<option value="file11">github.com/IBM/ibmcloud-volume-vpc/block/provider/get_volume.go (100.0%)</option>
				
				<option value="file12">github.com/IBM/ibmcloud-volume-vpc/block/provider/get_volume_attachment.go (100.0%)</option>
				
				<option value="file13">github.com/IBM/ibmcloud-volume-vpc/block/provider/get_volume_with_request_id.go (100.0%)</option>
				
				<option value="file14">github.com/IBM/ibmcloud-volume-vpc/block/provider/list_snapshots.go (91.4%)</option>
				
				<option value="file15">github.com/IBM/ibmcloud-volume-vpc/block/provider/list_volumes.go (94.1%)</option>
				
				<option value="file16">github.com/IBM/ibmcloud-volume-vpc/block/provider/provider.go (66.0%)</option>
				
				<option value="file17">github.com/IBM/ibmcloud-volume-vpc/block/provider/session.go (100.0%)</option>
				
				<option value="file18">github.com/IBM/ibmcloud-volume-vpc/block/provider/token_generator.go (93.2%)</option>
				
				<option value="file19">github.com/IBM/ibmcloud-volume-vpc/block/provider/update_volume.go (0.0%)</option>
				
				<option value="file20">github.com/IBM/ibmcloud-volume-vpc/block/provider/util.go (87.7%)</option>
				
				<option value="file21">github.com/IBM/ibmcloud-volume-vpc/block/provider/wait_for_attach_volume.go (100.0%)</option>
				
				<option value="file22">github.com/IBM/ibmcloud-volume-vpc/block/provider/wait_for_detach_volume.go (100.0%)</option>
				
				<option value="file23">github.com/IBM/ibmcloud-volume-vpc/block/provider/wait_for_valid_volume_state.go (100.0%)</option>
				
				<option value="file24">github.com/IBM/ibmcloud-volume-vpc/common/auth/factory.go (62.5%)</option>
				
				<option value="file25">github.com/IBM/ibmcloud-volume-vpc/common/iam/token_exchange_iks.go (88.9%)</option>
				
				<option value="file26">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client/authentication.go (80.0%)</option>
				
				<option value="file27">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client/client.go (100.0%)</option>
				
				<option value="file28">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client/params.go (100.0%)</option>
				
				<option value="file29">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client/request.go (76.0%)</option>
				
				<option value="file30">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/attach_volume.go (100.0%)</option>
				
				<option value="file31">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/detach_volume.go (100.0%)</option>
				
				<option value="file32">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/get_volume_attachment.go (88.2%)</option>
				
				<option value="file33">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/iks_attach_volume.go (93.3%)</option>
				
				<option value="file34">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/iks_detach_volume.go (80.0%)</option>
				
				<option value="file35">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/iks_get_volume_attachment.go (86.7%)</option>
				
				<option value="file36">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/iks_list_volume_attachments.go (85.7%)</option>
				
				<option value="file37">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/list_volume_attachments.go (100.0%)</option>
				
				<option value="file38">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances/volume_mounter_service.go (100.0%)</option>
				
				<option value="file39">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/riaas/config.go (100.0%)</option>
				
				<option value="file40">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/riaas/riaas.go (74.1%)</option>
				
				<option value="file41">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/check_snapshot_tag.go (100.0%)</option>
				
				<option value="file42">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/check_volume_tag.go (100.0%)</option>
				
				<option value="file43">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/create_snapshot.go (100.0%)</option>
				
				<option value="file44">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/create_volume.go (100.0%)</option>
				
				<option value="file45">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/delete_snapshot.go (100.0%)</option>
				
				<option value="file46">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/delete_snapshot_tag.go (91.7%)</option>
				
				<option value="file47">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/delete_volume.go (100.0%)</option>
				
				<option value="file48">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/delete_volume_tag.go (100.0%)</option>
				
				<option value="file49">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/expand_volume.go (100.0%)</option>
				
				<option value="file50">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/get_snapshot.go (100.0%)</option>
				
				<option value="file51">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/get_volume.go (100.0%)</option>
				
				<option value="file52">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/iks_update_volume.go (90.9%)</option>
				
				<option value="file53">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/iks_volume_service.go (100.0%)</option>
				
				<option value="file54">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/list_snapshot_tags.go (100.0%)</option>
				
				<option value="file55">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/list_snapshots.go (100.0%)</option>
				
				<option value="file56">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/list_volume_tags.go (100.0%)</option>
				
				<option value="file57">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/list_volumes.go (100.0%)</option>
				
				<option value="file58">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/set_snapshot_tag.go (91.7%)</option>
				
				<option value="file59">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/set_volume_tag.go (100.0%)</option>
				
				<option value="file60">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/snapshot_service.go (100.0%)</option>
				
				<option value="file61">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/update_volume.go (0.0%)</option>
				
				<option value="file62">github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume/volume_service.go (100.0%)</option>
				
				<option value="file63">github.com/IBM/ibmcloud-volume-vpc/iks/provider/provider.go (47.1%)</option>
				
				<option value="file64">github.com/IBM/ibmcloud-volume-vpc/iks/provider/session.go (16.7%)</option>
				
				<option value="file65">github.com/IBM/ibmcloud-volume-vpc/iks/provider/update_volume.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/utils/reasoncode"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"

        "go.uber.org/zap"
)

//VpcVolumeAttachment ...
const (
        VpcVolumeAttachment = "vpcVolumeAttachment"
        StatusAttached      = "attached"
        StatusAttaching     = "attaching"
        StatusDetaching     = "detaching"
)

// AttachVolume attach volume based on given volume attachment request
func (vpcs *VPCSession) AttachVolume(volumeAttachmentRequest provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of AttachVolume method...")
        defer vpcs.Logger.Debug("Exit from AttachVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "AttachVolume", time.Now())
        var err error

        //check if ServiceSession is valid
        if err = isValidServiceSession(vpcs); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Validating basic inputs for Attach method...", zap.Reflect("volumeAttachRequest", volumeAttachmentRequest))
        err = vpcs.validateAttachVolumeRequest(volumeAttachmentRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var volumeAttachResult *models.VolumeAttachment
        var varp *provider.VolumeAttachmentResponse
        // If it is Non IKS environment then remove the IKSVolumeAttachment field from request struct which contains clusterID.
        // TO-DO : Enhance this check. Put it in right place
        if !vpcs.Config.VPCConfig.IsIKS </span><span class="cov8" title="1">{
                volumeAttachmentRequest.IKSVolumeAttachment = nil
        }</span>
        <span class="cov8" title="1">volumeAttachment := models.NewVolumeAttachment(volumeAttachmentRequest)

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                // First , check if volume is already attached or attaching to given instance
                vpcs.Logger.Info("Checking if volume is already attached by other thread")
                currentVolAttachment, err := vpcs.GetVolumeAttachment(volumeAttachmentRequest)
                if err == nil &amp;&amp; currentVolAttachment != nil &amp;&amp; currentVolAttachment.Status != StatusDetaching </span><span class="cov8" title="1">{
                        vpcs.Logger.Info("Volume is already attached", zap.Reflect("currentVolAttachment", currentVolAttachment))
                        varp = currentVolAttachment
                        return nil, true // stop retry volume already attached
                }</span>
                //Try attaching volume if it's not already attached or there is error in getting current volume attachment
                <span class="cov8" title="1">vpcs.Logger.Info("Attaching volume from VPC provider...", zap.Bool("IKSEnabled?", vpcs.Config.VPCConfig.IsIKS))
                volumeAttachResult, err = vpcs.APIClientVolAttachMgr.AttachVolume(&amp;volumeAttachment, vpcs.Logger)
                // Keep retry, until we get the proper volumeAttachResult object
                if err != nil </span><span class="cov8" title="1">{
                        return err, skipRetryForObviousErrors(err, vpcs.Config.VPCConfig.IsIKS)
                }</span>
                <span class="cov8" title="1">varp = volumeAttachResult.ToVolumeAttachmentResponse(vpcs.Config.VPCConfig.VPCBlockProviderType)
                return err, true</span> // stop retry as no error
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                userErr := userError.GetUserError(string(userError.VolumeAttachFailed), err, volumeAttachmentRequest.VolumeID, volumeAttachmentRequest.InstanceID)
                return nil, userErr
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully attached volume from VPC provider", zap.Reflect("volumeResponse", varp))
        return varp, nil</span>
}

// validateVolume validating volume ID
func (vpcs *VPCSession) validateAttachVolumeRequest(volumeAttachRequest provider.VolumeAttachmentRequest) error <span class="cov8" title="1">{
        var err error
        // Check for InstanceID - required validation
        if len(volumeAttachRequest.InstanceID) == 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError(string(reasoncode.ErrorRequiredFieldMissing), nil, "InstanceID")
                vpcs.Logger.Error("volumeAttachRequest.InstanceID is required", zap.Error(err))
                return err
        }</span>
        // Check for VolumeID - required validation
        <span class="cov8" title="1">if len(volumeAttachRequest.VolumeID) == 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError(string(reasoncode.ErrorRequiredFieldMissing), nil, "VolumeID")
                vpcs.Logger.Error("volumeAttachRequest.VolumeID is required", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

//AuthorizeVolume allows aceess to volume  based on given authorization
func (vpcs *VPCSession) AuthorizeVolume(volumeAuthorization provider.VolumeAuthorization) error <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry AuthorizeVolume", zap.Reflect("volumeAuthorization", volumeAuthorization))
        defer vpcs.Logger.Info("Exit AuthorizeVolume", zap.Reflect("volumeAuthorization", volumeAuthorization))

        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/utils/reasoncode"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// CreateSnapshot creates snapshot
func (vpcs *VPCSession) CreateSnapshot(snapshotRequest provider.SnapshotRequest) (*provider.Snapshot, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry CreateSnapshot", zap.Reflect("snapshotRequest", snapshotRequest))
        defer vpcs.Logger.Info("Exit CreateSnapshot", zap.Reflect("snapshotRequest", snapshotRequest))
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "CreateSnapshot", time.Now())
        var err error

        vpcs.Logger.Info("Validating basic inputs for CreateSnapshot method...", zap.Reflect("snapshotRequest", snapshotRequest))
        err = vpcs.validateSnapshotRequest(snapshotRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var snapshotResult *models.Snapshot

        // Step 1- validate input which are required
        vpcs.Logger.Info("Requested volume is:", zap.Reflect("Volume", snapshotRequest.SourceVolumeID))

        var volume *models.Volume
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.VolumeService().GetVolume(snapshotRequest.SourceVolumeID, vpcs.Logger)
                return err
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithVolumeId", err, "Not a valid volume ID")
        }</span>

        <span class="cov8" title="1">if volume == nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithVolumeId", err, snapshotRequest.SourceVolumeID, "Not a valid volume ID")
        }</span>
        <span class="cov8" title="1">snapshotTemplate := &amp;models.Snapshot{
                Name:         *snapshotRequest.Name,
                SourceVolume: &amp;models.SourceVolume{ID: snapshotRequest.SourceVolumeID},
        }

        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                snapshotResult, err = vpcs.Apiclient.SnapshotService().CreateSnapshot(snapshotTemplate, vpcs.Logger)
                return err
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, userError.GetUserError("SnapshotSpaceOrderFailed", err)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully created snapshot with backend (vpcclient) call")
        vpcs.Logger.Info("Backend created snapshot details", zap.Reflect("Snapshot", snapshotResult))
        respSnapshot := &amp;provider.Snapshot{
                VolumeID:             snapshotResult.SourceVolume.ID,
                SnapshotID:           snapshotResult.ID,
                SnapshotCreationTime: *snapshotResult.CreatedAt,
                SnapshotSize:         snapshotResult.Size,
        }
        if snapshotResult.LifecycleState == "stable" </span><span class="cov0" title="0">{
                respSnapshot.ReadyToUse = true
        }</span> else<span class="cov8" title="1"> {
                respSnapshot.ReadyToUse = false
        }</span>
        <span class="cov8" title="1">return respSnapshot, nil</span>
}

// validateSnapshotRequest validates request for snapshot
func (vpcs *VPCSession) validateSnapshotRequest(snapshorRequest provider.SnapshotRequest) error <span class="cov8" title="1">{
        var err error
        // Check for snapshot Name - required validation
        if snapshorRequest.Name == nil </span><span class="cov8" title="1">{
                err = userError.GetUserError(string(reasoncode.ErrorRequiredFieldMissing), nil, "Name")
                vpcs.Logger.Error("snapshorRequest.Name is required", zap.Error(err))
                return err
        }</span> else<span class="cov8" title="1"> if len(*snapshorRequest.Name) == 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError(string(reasoncode.ErrorRequiredFieldMissing), nil, "Name")
                vpcs.Logger.Error("snapshorRequest.Name is required", zap.Error(err))
                return err
        }</span>
        // Check for VolumeID - required validation
        <span class="cov8" title="1">if len(snapshorRequest.SourceVolumeID) == 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError(string(reasoncode.ErrorRequiredFieldMissing), nil, "SourceVolumeID")
                vpcs.Logger.Error("snapshorRequest.SourceVolumeID is required", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

const (
        customProfile = "custom"
        minSize       = 10
)

// CreateVolume Get the volume by using ID
func (vpcs *VPCSession) CreateVolume(volumeRequest provider.Volume) (volumeResponse *provider.Volume, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of CreateVolume method...")
        defer vpcs.Logger.Debug("Exit from CreateVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "CreateVolume", time.Now())

        vpcs.Logger.Info("Basic validation for CreateVolume request... ", zap.Reflect("RequestedVolumeDetails", volumeRequest))
        resourceGroup, iops, err := validateVolumeRequest(volumeRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully validated inputs for CreateVolume request... ")

        // Build the template to send to backend
        volumeTemplate := &amp;models.Volume{
                Name:          *volumeRequest.Name,
                Capacity:      int64(*volumeRequest.Capacity),
                Iops:          iops,
                ResourceGroup: &amp;resourceGroup,
                Profile: &amp;models.Profile{
                        Name: volumeRequest.VPCVolume.Profile.Name,
                },
                Zone: &amp;models.Zone{
                        Name: volumeRequest.Az,
                },
        }
        // validate and add snapshot ID  if is provided
        if len(volumeRequest.SnapshotID) &gt; 0 </span><span class="cov0" title="0">{
                volumeTemplate.SourceSnapshot = &amp;models.Snapshot{ID: volumeRequest.SnapshotID}
        }</span>

        <span class="cov8" title="1">var encryptionKeyCRN string
        if volumeRequest.VPCVolume.VolumeEncryptionKey != nil &amp;&amp; len(volumeRequest.VPCVolume.VolumeEncryptionKey.CRN) &gt; 0 </span><span class="cov8" title="1">{
                encryptionKeyCRN = volumeRequest.VPCVolume.VolumeEncryptionKey.CRN
                volumeTemplate.VolumeEncryptionKey = &amp;models.VolumeEncryptionKey{CRN: encryptionKeyCRN}
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Calling VPC provider for volume creation...")
        var volume *models.Volume
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.VolumeService().CreateVolume(volumeTemplate, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                vpcs.Logger.Debug("Failed to create volume from VPC provider", zap.Reflect("BackendError", err))
                return nil, userError.GetUserError("FailedToPlaceOrder", err)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully created volume from VPC provider...", zap.Reflect("VolumeDetails", volume))

        vpcs.Logger.Info("Waiting for volume to be in valid (available) state", zap.Reflect("VolumeDetails", volume))
        err = WaitForValidVolumeState(vpcs, volume.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("VolumeNotInValidState", err, volume.ID)
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Volume got valid (available) state", zap.Reflect("VolumeDetails", volume))

        // Converting volume to lib volume type
        volumeResponse = FromProviderToLibVolume(volume, vpcs.Logger)
        // VPC does have region yet . So use requested region in response
        volumeResponse.Region = volumeRequest.Region
        // Return reuested tag as is if not tags returned by backend
        if len(volumeResponse.Tags) == 0 &amp;&amp; len(volumeRequest.Tags) &gt; 0 </span><span class="cov0" title="0">{
                volumeResponse.Tags = volumeRequest.Tags
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("VolumeResponse", zap.Reflect("volumeResponse", volumeResponse))
        return volumeResponse, err</span>
}

// validateVolumeRequest validating volume request
func validateVolumeRequest(volumeRequest provider.Volume) (models.ResourceGroup, int64, error) <span class="cov8" title="1">{
        resourceGroup := models.ResourceGroup{}
        var iops int64
        iops = 0
        // Volume name should not be empty
        if volumeRequest.Name == nil </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("InvalidVolumeName", nil, nil)
        }</span> else<span class="cov8" title="1"> if len(*volumeRequest.Name) == 0 </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("InvalidVolumeName", nil, *volumeRequest.Name)
        }</span>

        // Capacity should not be empty
        <span class="cov8" title="1">if volumeRequest.Capacity == nil </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("VolumeCapacityInvalid", nil, nil)
        }</span> else<span class="cov8" title="1"> if *volumeRequest.Capacity &lt; minSize </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("VolumeCapacityInvalid", nil, *volumeRequest.Capacity)
        }</span>

        // Read user provided error, no harm to pass the 0 values to RIaaS in case of tiered profiles
        <span class="cov8" title="1">if volumeRequest.Iops != nil </span><span class="cov8" title="1">{
                iops = ToInt64(*volumeRequest.Iops)
        }</span>
        <span class="cov8" title="1">if volumeRequest.VPCVolume.Profile == nil </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("VolumeProfileEmpty", nil)
        }</span>
        <span class="cov8" title="1">if volumeRequest.VPCVolume.Profile.Name != customProfile &amp;&amp; iops &gt; 0 </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("VolumeProfileIopsInvalid", nil)
        }</span>

        // validate and add resource group ID or Name whichever is provided by user
        <span class="cov8" title="1">if volumeRequest.VPCVolume.ResourceGroup == nil </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("EmptyResourceGroup", nil)
        }</span>

        // validate and add resource group ID or Name whichever is provided by user
        <span class="cov8" title="1">if len(volumeRequest.VPCVolume.ResourceGroup.ID) == 0 &amp;&amp; len(volumeRequest.VPCVolume.ResourceGroup.Name) == 0 </span><span class="cov8" title="1">{
                return resourceGroup, iops, userError.GetUserError("EmptyResourceGroupIDandName", nil)
        }</span>

        <span class="cov8" title="1">if len(volumeRequest.VPCVolume.ResourceGroup.ID) &gt; 0 </span><span class="cov8" title="1">{
                resourceGroup.ID = volumeRequest.VPCVolume.ResourceGroup.ID
        }</span>
        <span class="cov8" title="1">if len(volumeRequest.VPCVolume.ResourceGroup.Name) &gt; 0 </span><span class="cov8" title="1">{
                // get the resource group ID from resource group name as Name is not supported by RIaaS
                resourceGroup.Name = volumeRequest.VPCVolume.ResourceGroup.Name
        }</span>
        <span class="cov8" title="1">return resourceGroup, iops, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// CreateVolumeFromSnapshot creates the volume by using ID
func (vpcs *VPCSession) CreateVolumeFromSnapshot(snapshot provider.Snapshot, tags map[string]string) (*provider.Volume, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry CreateVolumeFromSnapshot", zap.Reflect("Snapshot", snapshot))
        defer vpcs.Logger.Info("Exit CreateVolumeFromSnapshot", zap.Reflect("Snapshot", snapshot))

        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DeleteSnapshot delete snapshot
func (vpcs *VPCSession) DeleteSnapshot(snapshot *provider.Snapshot) error <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry DeleteSnapshot", zap.Reflect("snapshot", snapshot))
        defer vpcs.Logger.Info("Exit DeleteSnapshot", zap.Reflect("snapshot", snapshot))
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "DeleteSnapshot", time.Now())

        var err error
        if snapshot == nil </span><span class="cov8" title="1">{
                err = userError.GetUserError("InvalidSnapshotID", nil, nil)
                return err
        }</span>

        <span class="cov8" title="1">_, err = vpcs.GetSnapshot(snapshot.SnapshotID)
        if err != nil </span><span class="cov8" title="1">{
                return userError.GetUserError("StorageFindFailedWithSnapshotId", err, snapshot.SnapshotID, "Not a valid snapshot ID")
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Deleting snapshot from VPC provider...")
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                err = vpcs.Apiclient.SnapshotService().DeleteSnapshot(snapshot.SnapshotID, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return userError.GetUserError("FailedToDeleteSnapshot", err)
        }</span>

        <span class="cov8" title="1">err = WaitForSnapshotDeletion(vpcs, snapshot.SnapshotID)
        if err != nil </span><span class="cov0" title="0">{
                return userError.GetUserError("FailedToDeleteSnapshot", err, snapshot.SnapshotID)
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully deleted the snapshot with backend (vpcclient) call)")
        return err</span>
}

// WaitForSnapshotDeletion checks the snapshot for valid status
func WaitForSnapshotDeletion(vpcs *VPCSession, snapshotID string) (err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForSnapshotDeletion method...")
        defer vpcs.Logger.Debug("Exit from WaitForSnapshotDeletion method...")
        var skip = false

        vpcs.Logger.Info("Getting snapshot details from VPC provider...", zap.Reflect("snapshotID", snapshotID))

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                _, err = vpcs.Apiclient.SnapshotService().GetSnapshot(snapshotID, vpcs.Logger)
                // Keep retry, until GetSnapshot returns snapshots_not_found
                if err != nil </span><span class="cov0" title="0">{
                        skip = skipRetry(err.(*models.Error))
                        return nil, skip
                }</span>
                <span class="cov8" title="1">return err, false</span> // continue retry as we are not seeing error which means snapshot is available
        })

        <span class="cov8" title="1">if err == nil &amp;&amp; skip </span><span class="cov0" title="0">{
                vpcs.Logger.Info("Snapshot got deleted.", zap.Reflect("snapshotID", snapshotID))
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DeleteVolume deletes the volume
func (vpcs *VPCSession) DeleteVolume(volume *provider.Volume) (err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of DeleteVolume method...")
        defer vpcs.Logger.Debug("Exit from DeleteVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "DeleteVolume", time.Now())

        vpcs.Logger.Info("Validating basic inputs for DeleteVolume method...", zap.Reflect("VolumeDetails", volume))
        err = validateVolume(volume)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Deleting volume from VPC provider...")
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                err = vpcs.Apiclient.VolumeService().DeleteVolume(volume.VolumeID, vpcs.Logger)
                return err
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return userError.GetUserError("failedToDeleteVolume", err, volume.VolumeID)
        }</span>

        <span class="cov8" title="1">err = WaitForVolumeDeletion(vpcs, volume.VolumeID)
        if err != nil </span><span class="cov0" title="0">{
                return userError.GetUserError("failedToDeleteVolume", err, volume.VolumeID)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully deleted volume from VPC provider")
        return err</span>
}

// validateVolume validating volume ID
func validateVolume(volume *provider.Volume) (err error) <span class="cov8" title="1">{
        if volume == nil </span><span class="cov8" title="1">{
                err = userError.GetUserError("InvalidVolumeID", nil, nil)
                return
        }</span>

        <span class="cov8" title="1">if IsValidVolumeIDFormat(volume.VolumeID) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err = userError.GetUserError("InvalidVolumeID", nil, volume.VolumeID)
        return</span>
}

// WaitForVolumeDeletion checks the volume for valid status
func WaitForVolumeDeletion(vpcs *VPCSession, volumeID string) (err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForVolumeDeletion method...")
        defer vpcs.Logger.Debug("Exit from WaitForVolumeDeletion method...")
        var skip = false

        vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("VolumeID", volumeID))

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                _, err = vpcs.Apiclient.VolumeService().GetVolume(volumeID, vpcs.Logger)
                // Keep retry, until GetVolume returns volume not found
                if err != nil </span><span class="cov0" title="0">{
                        skip = skipRetry(err.(*models.Error))
                        return nil, skip
                }</span>
                <span class="cov8" title="1">return err, false</span> // continue retry as we are not seeing error which means volume is available
        })

        <span class="cov8" title="1">if err == nil &amp;&amp; skip </span><span class="cov0" title="0">{
                vpcs.Logger.Info("Volume got deleted.", zap.Reflect("volumeID", volumeID))
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"

        "net/http"
        "time"

        "go.uber.org/zap"
)

// DetachVolume detach volume based on given volume attachment request
func (vpcs *VPCSession) DetachVolume(volumeAttachmentTemplate provider.VolumeAttachmentRequest) (*http.Response, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of DetachVolume method...")
        defer vpcs.Logger.Debug("Exit from DetachVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "DetachVolume", time.Now())
        var err error

        //check if ServiceSession is valid
        if err = isValidServiceSession(vpcs); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Validating basic inputs for detach method...", zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate))
        err = vpcs.validateAttachVolumeRequest(volumeAttachmentTemplate)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var response *http.Response
        var volumeAttachment models.VolumeAttachment

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                // First , check if volume is already attached to given instance
                vpcs.Logger.Info("Checking if volume is already attached ")
                currentVolAttachment, err := vpcs.GetVolumeAttachment(volumeAttachmentTemplate)
                if err == nil &amp;&amp; currentVolAttachment.Status != StatusDetaching </span><span class="cov8" title="1">{
                        // If no error and current volume is not already in detaching state ( i.e in attached or attaching state) attempt to detach
                        vpcs.Logger.Info("Found volume attachment", zap.Reflect("currentVolAttachment", currentVolAttachment))
                        volumeAttachment := models.NewVolumeAttachment(volumeAttachmentTemplate)
                        volumeAttachment.ID = currentVolAttachment.VPCVolumeAttachment.ID
                        vpcs.Logger.Info("Detaching volume from VPC provider...")
                        response, err = vpcs.APIClientVolAttachMgr.DetachVolume(&amp;volumeAttachment, vpcs.Logger) //nolint:bodyclose

                        if err != nil </span><span class="cov8" title="1">{
                                return err, skipRetryForObviousErrors(err, vpcs.Config.VPCConfig.IsIKS) // Retry in case of all errors
                        }</span>
                }
                <span class="cov8" title="1">vpcs.Logger.Info("No volume attachment found for", zap.Reflect("currentVolAttachment", currentVolAttachment), zap.Error(err))
                // consider volume detach success if its  already  in Detaching or VolumeAttachment is not found
                response = &amp;http.Response{
                        StatusCode: http.StatusOK,
                }
                return nil, true</span> // skip retry if volume is not found OR alreadd in detaching state
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                userErr := userError.GetUserError(string(userError.VolumeDetachFailed), err, volumeAttachmentTemplate.VolumeID, volumeAttachmentTemplate.InstanceID, volumeAttachment.ID)
                vpcs.Logger.Error("Volume detach failed with error", zap.Error(err))
                return response, userErr
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully detached volume from VPC provider", zap.Reflect("resp", response))
        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/utils/reasoncode"
)

// Error implements the error interface for a Fault.
// Most easily constructed using util.NewError() or util.NewErrorWithProperties()
type Error struct {
        // Fault ...
        Fault Fault
}

// Fault encodes a fault condition.
// Does not implement the error interface so that cannot be accidentally
// misassigned to error variables when returned in a function response.
type Fault struct {
        // Message is the fault message (required)
        Message string `json:"msg"`

        // ReasonCode is fault reason code (required)  //TODO: will have better reasoncode mechanism
        ReasonCode reasoncode.ReasonCode `json:"code"`

        // WrappedErrors contains wrapped error messages (if applicable)
        Wrapped []string `json:"wrapped,omitempty"`

        // Properties contains diagnostic properties (if applicable)
        Properties map[string]string `json:"properties,omitempty"`
}

// FaultResponse is an optional Fault
type FaultResponse struct {
        Fault *Fault `json:"fault,omitempty"`
}

var _ error = Error{}

// Error satisfies the error contract
func (err Error) Error() string <span class="cov8" title="1">{
        return err.Fault.Message
}</span>

// Code satisfies the legacy provider.Error interface
func (err Error) Code() reasoncode.ReasonCode <span class="cov8" title="1">{
        if err.Fault.ReasonCode == "" </span><span class="cov8" title="1">{
                return reasoncode.ErrorUnclassified
        }</span>
        <span class="cov8" title="1">return err.Fault.ReasonCode</span>
}

// Wrapped mirrors the legacy provider.Error interface
func (err Error) Wrapped() []string <span class="cov8" title="1">{
        return err.Fault.Wrapped
}</span>

// Properties satisfies the legacy provider.Error interface
func (err Error) Properties() map[string]string <span class="cov8" title="1">{
        return err.Fault.Properties
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GiB ...
const (
        GiB = 1024 * 1024 * 1024
)

// ExpandVolume Get the volume by using ID
func (vpcs *VPCSession) ExpandVolume(expandVolumeRequest provider.ExpandVolumeRequest) (size int64, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of ExpandVolume method...")
        defer vpcs.Logger.Debug("Exit from ExpandVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "ExpandVolume", time.Now())

        // Get volume details
        existVolume, err := vpcs.GetVolume(expandVolumeRequest.VolumeID)
        if err != nil </span><span class="cov8" title="1">{
                return -1, err
        }</span>
        // Return existing Capacity if its greater or equal to expandable size
        <span class="cov8" title="1">if existVolume.Capacity != nil &amp;&amp; int64(*existVolume.Capacity) &gt;= expandVolumeRequest.Capacity </span><span class="cov8" title="1">{
                return int64(*existVolume.Capacity), nil
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Successfully validated inputs for ExpandVolume request... ")

        newSize := roundUpSize(expandVolumeRequest.Capacity, GiB)

        // Build the template to send to backend
        volumeTemplate := &amp;models.Volume{
                Capacity: newSize,
        }

        vpcs.Logger.Info("Calling VPC provider for volume expand...")
        var volume *models.Volume
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.VolumeService().ExpandVolume(expandVolumeRequest.VolumeID, volumeTemplate, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                vpcs.Logger.Debug("Failed to expand volume from VPC provider", zap.Reflect("BackendError", err))
                return -1, userError.GetUserError("FailedToExpandVolume", err)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully accepted volume expansion request, now waiting for volume state equal to available")
        err = WaitForValidVolumeState(vpcs, volume.ID)
        if err != nil </span><span class="cov0" title="0">{
                return -1, userError.GetUserError("VolumeNotInValidState", err, volume.ID)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Volume got valid (available) state", zap.Reflect("VolumeDetails", volume))
        return expandVolumeRequest.Capacity, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GetSnapshot get snapshot
func (vpcs *VPCSession) GetSnapshot(snapshotID string) (*provider.Snapshot, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry GetSnapshot", zap.Reflect("SnapshotID", snapshotID))
        defer vpcs.Logger.Info("Exit GetSnapshot", zap.Reflect("SnapshotID", snapshotID))

        vpcs.Logger.Info("Getting snapshot details from VPC provider...", zap.Reflect("SnapshotID", snapshotID))

        var snapshot *models.Snapshot
        var err error
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                snapshot, err = vpcs.Apiclient.SnapshotService().GetSnapshot(snapshotID, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithSnapshotId", err, snapshotID)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved snpashot details from VPC backend", zap.Reflect("snapshotDetails", snapshot))
        respSnapshot := &amp;provider.Snapshot{
                VolumeID:             snapshot.SourceVolume.ID,
                SnapshotID:           snapshot.ID,
                SnapshotCreationTime: *snapshot.CreatedAt,
                SnapshotSize:         snapshot.Size,
        }
        if snapshot.LifecycleState == "stable" </span><span class="cov8" title="1">{
                respSnapshot.ReadyToUse = true
        }</span> else<span class="cov8" title="1"> {
                respSnapshot.ReadyToUse = false
        }</span>
        <span class="cov8" title="1">return respSnapshot, nil</span>
}

// GetSnapshotByName ...
func (vpcs *VPCSession) GetSnapshotByName(name string) (respSnap *provider.Snapshot, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetSnapshotByName method...")
        defer vpcs.Logger.Debug("Exit from GetSnapshotByName method...")

        vpcs.Logger.Info("Basic validation for snapshot Name...", zap.Reflect("SnapshotName", name))
        if len(name) &lt;= 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError("InvalidSnapshotName", nil, name)
                return
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Getting snapshot details from VPC provider...", zap.Reflect("SnapshotName", name))

        var snapshot *models.Snapshot
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                snapshot, err = vpcs.Apiclient.SnapshotService().GetSnapshotByName(name, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithSnapshotName", err, snapshot)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved snpashot details from VPC backend", zap.Reflect("snapshotDetails", snapshot))
        respSnapshot := &amp;provider.Snapshot{
                VolumeID:             snapshot.SourceVolume.ID,
                SnapshotID:           snapshot.ID,
                SnapshotCreationTime: *snapshot.CreatedAt,
                SnapshotSize:         snapshot.Size,
        }
        if snapshot.LifecycleState == "stable" </span><span class="cov8" title="1">{
                respSnapshot.ReadyToUse = true
        }</span> else<span class="cov0" title="0"> {
                respSnapshot.ReadyToUse = false
        }</span>
        <span class="cov8" title="1">return respSnapshot, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GetVolume gets the volume by using ID
func (vpcs *VPCSession) GetVolume(id string) (respVolume *provider.Volume, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetVolume method...")
        defer vpcs.Logger.Debug("Exit from GetVolume method...")

        vpcs.Logger.Info("Basic validation for volume ID...", zap.Reflect("VolumeID", id))
        // validating volume ID
        err = validateVolumeID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("VolumeID", id))

        var volume *models.Volume
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.VolumeService().GetVolume(id, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithVolumeId", err, id)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved volume details from VPC backend", zap.Reflect("VolumeDetails", volume))

        // Converting volume to lib volume type
        respVolume = FromProviderToLibVolume(volume, vpcs.Logger)
        return respVolume, err</span>
}

// GetVolumeByName ...
func (vpcs *VPCSession) GetVolumeByName(name string) (respVolume *provider.Volume, err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetVolumeByName method...")
        defer vpcs.Logger.Debug("Exit from GetVolumeByName method...")

        vpcs.Logger.Info("Basic validation for volume Name...", zap.Reflect("VolumeName", name))
        if len(name) &lt;= 0 </span><span class="cov8" title="1">{
                err = userError.GetUserError("InvalidVolumeName", nil, name)
                return
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("VolumeName", name))

        var volume *models.Volume
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.VolumeService().GetVolumeByName(name, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("StorageFindFailedWithVolumeName", err, name)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved volume details from VPC backend", zap.Reflect("VolumeDetails", volume))

        // Converting volume to lib volume type
        respVolume = FromProviderToLibVolume(volume, vpcs.Logger)
        return respVolume, err</span>
}

// validateVolumeID validating basic volume ID
func validateVolumeID(volumeID string) (err error) <span class="cov8" title="1">{
        if IsValidVolumeIDFormat(volumeID) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err = userError.GetUserError("InvalidVolumeID", nil, volumeID)
        return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "errors"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GetVolumeAttachment  get the volume attachment based on the request
func (vpcs *VPCSession) GetVolumeAttachment(volumeAttachmentRequest provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of GetVolumeAttachment method...", zap.Reflect("volumeAttachmentRequest", volumeAttachmentRequest))
        defer vpcs.Logger.Debug("Exit from GetVolumeAttachment method...")
        var err error

        //check if ServiceSession is valid
        if err = isValidServiceSession(vpcs); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Validating basic inputs for GetVolumeAttachment method...", zap.Reflect("volumeAttachRequest", volumeAttachmentRequest))
        err = vpcs.validateAttachVolumeRequest(volumeAttachmentRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var volumeAttachmentResponse *provider.VolumeAttachmentResponse
        volumeAttachment := models.NewVolumeAttachment(volumeAttachmentRequest)
        if len(volumeAttachment.ID) &gt; 0 </span><span class="cov8" title="1">{
                //Get volume attachments by ID if it is specified
                volumeAttachmentResponse, err = vpcs.getVolumeAttachmentByID(volumeAttachment)
        }</span> else<span class="cov8" title="1"> {
                // Get volume attachment by Volume ID. This is inefficient operation which requires iteration over volume attachment list
                volumeAttachmentResponse, err = vpcs.getVolumeAttachmentByVolumeID(volumeAttachment)
        }</span>
        <span class="cov8" title="1">vpcs.Logger.Info("Volume attachment response", zap.Reflect("volumeAttachmentResponse", volumeAttachmentResponse), zap.Error(err))
        return volumeAttachmentResponse, err</span>
}

func (vpcs *VPCSession) getVolumeAttachmentByID(volumeAttachmentRequest models.VolumeAttachment) (*provider.VolumeAttachmentResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of getVolumeAttachmentByID()")
        defer vpcs.Logger.Debug("Exit from getVolumeAttachmentByID()")
        vpcs.Logger.Info("Getting VolumeAttachment from VPC provider...")
        var err error
        var volumeAttachmentResult *models.VolumeAttachment
        /*err = retry(vpcs.Logger, func() error {
                volumeAttachmentResult, err = vpcs.APIClientVolAttachMgr.GetVolumeAttachment(&amp;volumeAttachmentRequest, vpcs.Logger)
                return err
        })*/

        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                volumeAttachmentResult, err = vpcs.APIClientVolAttachMgr.GetVolumeAttachment(&amp;volumeAttachmentRequest, vpcs.Logger)
                // Keep retry, until we get the proper volumeAttachmentRequest object
                if err != nil </span><span class="cov8" title="1">{
                        return err, skipRetryForObviousErrors(err, vpcs.Config.VPCConfig.IsIKS)
                }</span>
                <span class="cov8" title="1">return err, true</span> // stop retry as no error
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // API call is failed
                userErr := userError.GetUserError(string(userError.VolumeAttachFindFailed), err, volumeAttachmentRequest.Volume.ID, *volumeAttachmentRequest.InstanceID)
                return nil, userErr
        }</span>

        <span class="cov8" title="1">volumeAttachmentResponse := volumeAttachmentResult.ToVolumeAttachmentResponse(vpcs.Config.VPCConfig.VPCBlockProviderType)
        vpcs.Logger.Info("Successfully retrieved volume attachment", zap.Reflect("volumeAttachmentResponse", volumeAttachmentResponse))
        return volumeAttachmentResponse, err</span>
}

func (vpcs *VPCSession) getVolumeAttachmentByVolumeID(volumeAttachmentRequest models.VolumeAttachment) (*provider.VolumeAttachmentResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of getVolumeAttachmentByVolumeID()")
        defer vpcs.Logger.Debug("Exit from getVolumeAttachmentByVolumeID()")
        vpcs.Logger.Info("Getting VolumeAttachmentList from VPC provider...")
        var volumeAttachmentList *models.VolumeAttachmentList
        var err error
        err = vpcs.APIRetry.FlexyRetry(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                volumeAttachmentList, err = vpcs.APIClientVolAttachMgr.ListVolumeAttachments(&amp;volumeAttachmentRequest, vpcs.Logger)
                // Keep retry, until we get the proper volumeAttachmentRequest object
                if err != nil </span><span class="cov8" title="1">{
                        return err, skipRetryForObviousErrors(err, vpcs.Config.VPCConfig.IsIKS)
                }</span>
                <span class="cov8" title="1">return err, true</span> // stop retry as no error
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // API call is failed
                userErr := userError.GetUserError(string(userError.VolumeAttachFindFailed), err, volumeAttachmentRequest.Volume.ID, *volumeAttachmentRequest.InstanceID)
                return nil, userErr
        }</span>
        // Iterate over the volume attachment list for given instance
        <span class="cov8" title="1">for _, volumeAttachmentItem := range volumeAttachmentList.VolumeAttachments </span><span class="cov8" title="1">{
                // Check if volume ID is matching with requested volume ID
                if volumeAttachmentItem.Volume.ID == volumeAttachmentRequest.Volume.ID </span><span class="cov8" title="1">{
                        vpcs.Logger.Info("Successfully found volume attachment", zap.Reflect("volumeAttachment", volumeAttachmentItem))
                        volumeResponse := volumeAttachmentItem.ToVolumeAttachmentResponse(vpcs.Config.VPCConfig.VPCBlockProviderType)
                        vpcs.Logger.Info("Successfully fetched volume attachment from VPC provider", zap.Reflect("volumeResponse", volumeResponse))
                        return volumeResponse, nil
                }</span>
        }
        // No volume attahment found in the  list. So return error
        <span class="cov8" title="1">userErr := userError.GetUserError(string(userError.VolumeAttachFindFailed), errors.New("no VolumeAttachment Found"), volumeAttachmentRequest.Volume.ID, *volumeAttachmentRequest.InstanceID)
        vpcs.Logger.Error("Volume attachment not found", zap.Error(err))
        return nil, userErr</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "go.uber.org/zap"
)

// GetVolumeByRequestID get volume by volume ID
func (vpcs *VPCSession) GetVolumeByRequestID(requestID string) (*provider.Volume, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry GetVolumeByRequestID", zap.Reflect("requestID", requestID))
        defer vpcs.Logger.Info("Exit GetVolumeByRequestID", zap.Reflect("requestID", requestID))

        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "fmt"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ListSnapshots list all snapshots
func (vpcs *VPCSession) ListSnapshots(limit int, start string, tags map[string]string) (*provider.SnapshotList, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry ListeSnapshots")
        defer vpcs.Logger.Info("Exit ListSnapshots")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "ListSnapshots", time.Now())

        if limit &lt; 0 </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("InvalidListSnapshotLimit", nil, limit)
        }</span>

        <span class="cov8" title="1">if limit &gt; maxLimit </span><span class="cov0" title="0">{
                vpcs.Logger.Warn(fmt.Sprintf("listSnapshots requested max entries of %v, supports values &lt;= %v so defaulting value back to %v", limit, maxLimit, maxLimit))
                limit = maxLimit
        }</span>

        <span class="cov8" title="1">filters := &amp;models.LisSnapshotFilters{
                ResourceGroupID: tags["resource_group.id"],
                Name:            tags["name"],
                SourceVolumeID:  tags["source_volume.id"],
        }

        vpcs.Logger.Info("Getting snapshot list from VPC provider...", zap.Reflect("start", start), zap.Reflect("filters", filters))

        var snapshots *models.SnapshotList
        var err error
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                snapshots, err = vpcs.Apiclient.SnapshotService().ListSnapshots(limit, start, filters, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("ListSnapshotsFailed", err)
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved snapshot list from VPC backend", zap.Reflect("SnapshotList", snapshots))

        var respSnapshotList = &amp;provider.SnapshotList{}
        if snapshots != nil </span><span class="cov8" title="1">{
                if snapshots.Next != nil </span><span class="cov8" title="1">{
                        var next string
                        // "Next":{"href":"https://eu-gb.iaas.cloud.ibm.com/v1/snapshots?start=3e898aa7-ac71-4323-952d-a8d741c65a68\u0026limit=1\u0026zone.name=eu-gb-1"}
                        if strings.Contains(snapshots.Next.Href, "start=") </span><span class="cov8" title="1">{
                                next = strings.Split(strings.Split(snapshots.Next.Href, "start=")[1], "\u0026")[0]
                        }</span> else<span class="cov8" title="1"> {
                                vpcs.Logger.Warn("snapshots.Next.Href is not in expected format", zap.Reflect("snapshots.Next.Href", snapshots.Next.Href))
                        }</span>
                        <span class="cov8" title="1">respSnapshotList.Next = next</span>
                }

                <span class="cov8" title="1">snapshotslist := snapshots.Snapshots
                if len(snapshotslist) &gt; 0 </span><span class="cov8" title="1">{
                        for _, snapItem := range snapshotslist </span><span class="cov8" title="1">{
                                respSnapshot := &amp;provider.Snapshot{
                                        VolumeID:             snapItem.SourceVolume.ID,
                                        SnapshotID:           snapItem.ID,
                                        SnapshotCreationTime: *snapItem.CreatedAt,
                                        SnapshotSize:         snapItem.Size,
                                }
                                if snapItem.LifecycleState == "stable" </span><span class="cov8" title="1">{
                                        respSnapshot.ReadyToUse = true
                                }</span> else<span class="cov0" title="0"> {
                                        respSnapshot.ReadyToUse = false
                                }</span>
                                <span class="cov8" title="1">respSnapshotList.Snapshots = append(respSnapshotList.Snapshots, respSnapshot)</span>
                        }
                }
        }
        <span class="cov8" title="1">return respSnapshotList, err</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "fmt"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

const (
        maxLimit                 = 100
        startVolumeIDNotFoundMsg = "start parameter is not valid"
)

// ListVolumes list all volumes
func (vpcs *VPCSession) ListVolumes(limit int, start string, tags map[string]string) (*provider.VolumeList, error) <span class="cov8" title="1">{
        vpcs.Logger.Info("Entry ListVolumes", zap.Reflect("start", start), zap.Reflect("filters", tags))
        defer vpcs.Logger.Info("Exit ListVolumes", zap.Reflect("start", start), zap.Reflect("filters", tags))
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "ListVolumes", time.Now())

        if limit &lt; 0 </span><span class="cov8" title="1">{
                return nil, userError.GetUserError("InvalidListVolumesLimit", nil, limit)
        }</span>

        <span class="cov8" title="1">if limit &gt; maxLimit </span><span class="cov0" title="0">{
                vpcs.Logger.Warn(fmt.Sprintf("listVolumes requested max entries of %v, supports values &lt;= %v so defaulting value back to %v", limit, maxLimit, maxLimit))
                limit = maxLimit
        }</span>

        <span class="cov8" title="1">filters := &amp;models.ListVolumeFilters{
                // Tag:          tags["tag"],
                ResourceGroupID: tags["resource_group.id"],
                ZoneName:        tags["zone.name"],
                VolumeName:      tags["name"],
        }

        vpcs.Logger.Info("Getting volumes list from VPC provider...", zap.Reflect("start", start), zap.Reflect("filters", filters))

        var volumes *models.VolumeList
        var err error
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volumes, err = vpcs.Apiclient.VolumeService().ListVolumes(limit, start, filters, vpcs.Logger)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), startVolumeIDNotFoundMsg) </span><span class="cov8" title="1">{
                        return nil, userError.GetUserError("StartVolumeIDNotFound", err, start)
                }</span>
                <span class="cov8" title="1">return nil, userError.GetUserError("ListVolumesFailed", err)</span>
        }

        <span class="cov8" title="1">vpcs.Logger.Info("Successfully retrieved volumes list from VPC backend", zap.Reflect("VolumesList", volumes))

        var respVolumesList = &amp;provider.VolumeList{}
        if volumes != nil </span><span class="cov8" title="1">{
                if volumes.Next != nil </span><span class="cov8" title="1">{
                        var next string
                        // "Next":{"href":"https://eu-gb.iaas.cloud.ibm.com/v1/volumes?start=3e898aa7-ac71-4323-952d-a8d741c65a68\u0026limit=1\u0026zone.name=eu-gb-1"}
                        if strings.Contains(volumes.Next.Href, "start=") </span><span class="cov8" title="1">{
                                next = strings.Split(strings.Split(volumes.Next.Href, "start=")[1], "\u0026")[0]
                        }</span> else<span class="cov8" title="1"> {
                                vpcs.Logger.Warn("Volumes.Next.Href is not in expected format", zap.Reflect("volumes.Next.Href", volumes.Next.Href))
                        }</span>
                        <span class="cov8" title="1">respVolumesList.Next = next</span>
                }

                <span class="cov8" title="1">volumeslist := volumes.Volumes
                if len(volumeslist) &gt; 0 </span><span class="cov8" title="1">{
                        for _, volItem := range volumeslist </span><span class="cov8" title="1">{
                                volumeResponse := FromProviderToLibVolume(volItem, vpcs.Logger)
                                respVolumesList.Volumes = append(respVolumesList.Volumes, volumeResponse)
                        }</span>
                }
        }
        <span class="cov8" title="1">return respVolumesList, err</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        vpcconfig "github.com/IBM/ibmcloud-volume-vpc/block/vpcconfig"
        vpcauth "github.com/IBM/ibmcloud-volume-vpc/common/auth"
        "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/riaas"
        "go.uber.org/zap"
)

const (
        // VPCClassic ...
        VPCClassic = "gc"
        // VPCNextGen ...
        VPCNextGen = "g2"
        // PrivatePrefix ...
        PrivatePrefix = "private-"
        // BasePrivateURL ...
        BasePrivateURL = "https://" + PrivatePrefix
        // HTTPSLength ...
        HTTPSLength = 8
        // NEXTGenProvider ...
        NEXTGenProvider = 2
)

// VPCBlockProvider implements provider.Provider
type VPCBlockProvider struct {
        timeout        time.Duration
        Config         *vpcconfig.VPCBlockConfig
        tokenGenerator *tokenGenerator
        ContextCF      local.ContextCredentialsFactory

        ClientProvider riaas.RegionalAPIClientProvider
        httpClient     *http.Client
        APIConfig      riaas.Config
}

var _ local.Provider = &amp;VPCBlockProvider{}

// NewProvider initialises an instance of an IaaS provider.
func NewProvider(conf *vpcconfig.VPCBlockConfig, logger *zap.Logger) (local.Provider, error) <span class="cov8" title="1">{
        logger.Info("Entering NewProvider")

        if conf.VPCConfig == nil </span><span class="cov0" title="0">{
                return nil, errors.New("incomplete config for VPCBlockProvider")
        }</span>

        //Do config validation and enable only one generationType (i.e VPC-Classic | VPC-NG)
        <span class="cov8" title="1">gcConfigFound := (conf.VPCConfig.EndpointURL != "" || conf.VPCConfig.PrivateEndpointURL != "") &amp;&amp; (conf.VPCConfig.TokenExchangeURL != "" || conf.VPCConfig.IKSTokenExchangePrivateURL != "") &amp;&amp; (conf.VPCConfig.APIKey != "") &amp;&amp; (conf.VPCConfig.ResourceGroupID != "")
        g2ConfigFound := (conf.VPCConfig.G2EndpointPrivateURL != "" || conf.VPCConfig.G2EndpointURL != "") &amp;&amp; (conf.VPCConfig.IKSTokenExchangePrivateURL != "" || conf.VPCConfig.G2TokenExchangeURL != "") &amp;&amp; (conf.VPCConfig.G2APIKey != "") &amp;&amp; (conf.VPCConfig.G2ResourceGroupID != "")
        //if both config found, look for VPCTypeEnabled, otherwise default to GC
        //Incase of NG configurations, override the base properties.
        if (gcConfigFound &amp;&amp; g2ConfigFound &amp;&amp; conf.VPCConfig.VPCTypeEnabled == VPCNextGen) || (!gcConfigFound &amp;&amp; g2ConfigFound) </span><span class="cov0" title="0">{
                // overwrite the common variable in case of g2 i.e gen2, first preferences would be private endpoint
                if conf.VPCConfig.G2EndpointPrivateURL != "" </span><span class="cov0" title="0">{
                        conf.VPCConfig.EndpointURL = conf.VPCConfig.G2EndpointPrivateURL
                }</span> else<span class="cov0" title="0"> {
                        conf.VPCConfig.EndpointURL = conf.VPCConfig.G2EndpointURL
                }</span>

                // update iam based public toke exchange endpoint
                <span class="cov0" title="0">conf.VPCConfig.TokenExchangeURL = conf.VPCConfig.G2TokenExchangeURL

                conf.VPCConfig.APIKey = conf.VPCConfig.G2APIKey
                conf.VPCConfig.ResourceGroupID = conf.VPCConfig.G2ResourceGroupID

                //Set API Generation As 2 (if unspecified in config/ENV-VAR)
                if conf.VPCConfig.G2VPCAPIGeneration &lt;= 0 </span><span class="cov0" title="0">{
                        conf.VPCConfig.G2VPCAPIGeneration = NEXTGenProvider
                }</span>
                <span class="cov0" title="0">conf.VPCConfig.VPCAPIGeneration = conf.VPCConfig.G2VPCAPIGeneration

                //Set the APIVersion Date, it can be different in GC and NG
                if conf.VPCConfig.G2APIVersion != "" </span><span class="cov0" title="0">{
                        conf.VPCConfig.APIVersion = conf.VPCConfig.G2APIVersion
                }</span>

                //set provider-type (this usually comes from the secret)
                <span class="cov0" title="0">if conf.VPCConfig.VPCBlockProviderType != VPCNextGen </span><span class="cov0" title="0">{
                        conf.VPCConfig.VPCBlockProviderType = VPCNextGen
                }</span>

                //Mark this as enabled/active
                <span class="cov0" title="0">if conf.VPCConfig.VPCTypeEnabled != VPCNextGen </span><span class="cov0" title="0">{
                        conf.VPCConfig.VPCTypeEnabled = VPCNextGen
                }</span>
        } else<span class="cov8" title="1"> { //This is GC, no-override required
                conf.VPCConfig.VPCBlockProviderType = VPCClassic //incase of gc, i dont see its being set in slclient.toml, but NG cluster has this
                // For backward compatibility as some of the cluster storage secret may not have private gc endpoint url
                if conf.VPCConfig.PrivateEndpointURL != "" </span><span class="cov8" title="1">{
                        conf.VPCConfig.EndpointURL = conf.VPCConfig.PrivateEndpointURL
                }</span>
        }

        <span class="cov8" title="1">contextCF, err := vpcauth.NewVPCContextCredentialsFactory(conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">timeoutString := conf.VPCConfig.VPCTimeout
        if timeoutString == "" || timeoutString == "0s" </span><span class="cov8" title="1">{
                logger.Info("Using VPC default timeout")
                timeoutString = "120s"
        }</span>
        <span class="cov8" title="1">timeout, err := time.ParseDuration(timeoutString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpClient, err := config.GeneralCAHttpClientWithTimeout(timeout)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to prepare HTTP client", util.ZapError(err))
                return nil, err
        }</span>

        // SetRetryParameters sets the retry logic parameters
        <span class="cov8" title="1">SetRetryParameters(conf.VPCConfig.MaxRetryAttempt, conf.VPCConfig.MaxRetryGap)
        provider := &amp;VPCBlockProvider{
                timeout:        timeout,
                Config:         conf,
                tokenGenerator: &amp;tokenGenerator{config: conf.VPCConfig},
                ContextCF:      contextCF,
                httpClient:     httpClient,
                APIConfig: riaas.Config{
                        BaseURL:       conf.VPCConfig.EndpointURL,
                        HTTPClient:    httpClient,
                        APIVersion:    conf.VPCConfig.APIVersion,
                        APIGeneration: conf.VPCConfig.VPCAPIGeneration,
                        ResourceGroup: conf.VPCConfig.ResourceGroupID,
                },
        }
        // Update VPC config for IKS deployment
        provider.Config.VPCConfig.IsIKS = conf.IKSConfig != nil &amp;&amp; conf.IKSConfig.Enabled
        userError.MessagesEn = messages.InitMessages()
        return provider, nil</span>
}

// ContextCredentialsFactory ...
func (vpcp *VPCBlockProvider) ContextCredentialsFactory(zone *string) (local.ContextCredentialsFactory, error) <span class="cov8" title="1">{
        //  Datacenter name not required by VPC provider implementation
        return vpcp.ContextCF, nil
}</span>

// OpenSession opens a session on the provider
func (vpcp *VPCBlockProvider) OpenSession(ctx context.Context, contextCredentials provider.ContextCredentials, ctxLogger *zap.Logger) (provider.Session, error) <span class="cov8" title="1">{
        ctxLogger.Info("Entering OpenSession")
        defer metrics.UpdateDurationFromStart(ctxLogger, "OpenSession", time.Now())
        defer func() </span><span class="cov8" title="1">{
                ctxLogger.Debug("Exiting OpenSession")
        }</span>()

        // validate that we have what we need - i.e. valid credentials
        <span class="cov8" title="1">if contextCredentials.Credential == "" </span><span class="cov8" title="1">{
                return nil, util.NewError("Error Insufficient Authentication", "No authentication credential provided")
        }</span>

        <span class="cov8" title="1">if vpcp.Config.ServerConfig.DebugTrace </span><span class="cov8" title="1">{
                vpcp.APIConfig.DebugWriter = os.Stdout
        }</span>

        <span class="cov8" title="1">if vpcp.ClientProvider == nil </span><span class="cov8" title="1">{
                vpcp.ClientProvider = riaas.DefaultRegionalAPIClientProvider{}
        }</span>
        <span class="cov8" title="1">ctxLogger.Debug("", zap.Reflect("apiConfig.BaseURL", vpcp.APIConfig.BaseURL))

        if ctx != nil &amp;&amp; ctx.Value(provider.RequestID) != nil </span><span class="cov0" title="0">{
                // set ContextID only of speicifed in the context
                vpcp.APIConfig.ContextID = fmt.Sprintf("%v", ctx.Value(provider.RequestID))
                ctxLogger.Info("", zap.Reflect("apiConfig.ContextID", vpcp.APIConfig.ContextID))
        }</span>
        <span class="cov8" title="1">client, err := vpcp.ClientProvider.New(vpcp.APIConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a token for all other API calls
        <span class="cov8" title="1">token, err := getAccessToken(contextCredentials, ctxLogger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ctxLogger.Debug("", zap.Reflect("Token", token.Token))

        err = client.Login(token.Token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update retry logic default values
        <span class="cov8" title="1">if vpcp.Config.VPCConfig.MaxRetryAttempt &gt; 0 </span><span class="cov8" title="1">{
                ctxLogger.Debug("", zap.Reflect("MaxRetryAttempt", vpcp.Config.VPCConfig.MaxRetryAttempt))
                maxRetryAttempt = vpcp.Config.VPCConfig.MaxRetryAttempt
        }</span>
        <span class="cov8" title="1">if vpcp.Config.VPCConfig.MaxRetryGap &gt; 0 </span><span class="cov8" title="1">{
                ctxLogger.Debug("", zap.Reflect("MaxRetryGap", vpcp.Config.VPCConfig.MaxRetryGap))
                maxRetryGap = vpcp.Config.VPCConfig.MaxRetryGap
        }</span>

        <span class="cov8" title="1">vpcSession := &amp;VPCSession{
                VPCAccountID:          contextCredentials.IAMAccountID,
                Config:                vpcp.Config,
                ContextCredentials:    contextCredentials,
                VolumeType:            "vpc-block",
                Provider:              VPC,
                Apiclient:             client,
                APIClientVolAttachMgr: client.VolumeAttachService(),
                Logger:                ctxLogger,
                APIRetry:              NewFlexyRetryDefault(),
                SessionError:          nil,
        }
        return vpcSession, nil</span>
}

// UpdateAPIKey ...
func (vpcp *VPCBlockProvider) UpdateAPIKey(conf interface{}, logger *zap.Logger) error <span class="cov8" title="1">{
        logger.Info("Updating api key in vpc block provider")
        vpcConfig, ok := conf.(*vpcconfig.VPCBlockConfig)
        if !ok </span><span class="cov8" title="1">{
                logger.Error("Error fetching vpc block config from interface")
                return errors.New("error unmarshaling vpc block config")
        }</span>
        <span class="cov8" title="1">if vpcp.ContextCF == nil </span><span class="cov8" title="1">{
                logger.Error("Error updating api key, context credentials is not intiliazed")
                return errors.New("credentials not initliazed in the provider")
        }</span>
        <span class="cov0" title="0">err := vpcp.ContextCF.UpdateAPIKey(vpcConfig.VPCConfig.G2APIKey, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error updating api key in provider", zap.Error(err))
                return err
        }</span>
        // Updating the api key in VPC block provider
        <span class="cov0" title="0">vpcp.Config.VPCConfig.APIKey = vpcConfig.VPCConfig.G2APIKey
        vpcp.Config.VPCConfig.G2APIKey = vpcConfig.VPCConfig.G2APIKey
        vpcp.tokenGenerator.config.G2APIKey = vpcConfig.VPCConfig.G2APIKey
        vpcp.tokenGenerator.config.APIKey = vpcConfig.VPCConfig.G2APIKey
        return nil</span>
}

// getAccessToken ...
func getAccessToken(creds provider.ContextCredentials, logger *zap.Logger) (token *iam.AccessToken, err error) <span class="cov8" title="1">{
        switch creds.AuthType </span>{
        case provider.IAMAccessToken:<span class="cov8" title="1">
                token = &amp;iam.AccessToken{Token: creds.Credential}</span>
        default:<span class="cov0" title="0">
                err = errors.New("unknown AuthType")</span>
        }
        <span class="cov8" title="1">return</span>
}

// getPrivateEndpoint ...
func getPrivateEndpoint(logger *zap.Logger, publicEndPoint string) string <span class="cov8" title="1">{
        logger.Info("In getPrivateEndpoint, RIaaS public endpoint", zap.Reflect("URL", publicEndPoint))
        if !strings.Contains(publicEndPoint, PrivatePrefix) </span><span class="cov8" title="1">{
                if len(publicEndPoint) &gt; HTTPSLength </span><span class="cov8" title="1">{
                        return BasePrivateURL + publicEndPoint[HTTPSLength:]
                }</span>
        } else<span class="cov8" title="1"> {
                return publicEndPoint
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        vpcconfig "github.com/IBM/ibmcloud-volume-vpc/block/vpcconfig"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/riaas"
        "go.uber.org/zap"
)

// VPCSession implements lib.Session
type VPCSession struct {
        provider.DefaultVolumeProvider
        VPCAccountID          string
        Config                *vpcconfig.VPCBlockConfig
        ContextCredentials    provider.ContextCredentials
        VolumeType            provider.VolumeType
        Provider              provider.VolumeProvider
        Apiclient             riaas.RegionalAPI
        APIClientVolAttachMgr instances.VolumeAttachManager
        APIVersion            string
        Logger                *zap.Logger
        APIRetry              FlexyRetry
        SessionError          error
}

const (
        // VPC storage provider
        VPC = provider.VolumeProvider("VPC")
        // VolumeType ...
        VolumeType = provider.VolumeType("vpc-block")
        // SnapshotMask ...
        SnapshotMask = "id,username,capacityGb,createDate,snapshotCapacityGb,parentVolume[snapshotSizeBytes],parentVolume[snapshotCapacityGb],parentVolume[id],parentVolume[storageTierLevel],parentVolume[notes],storageType[keyName],serviceResource[datacenter[name]],billingItem[location,hourlyFlag],provisionedIops,lunId,originalVolumeName,storageTierLevel,notes"
)

var (
        // DeleteVolumeReason ...
        DeleteVolumeReason = "deleted by ibm-volume-lib on behalf of user request"
)

// Close at present does nothing
func (*VPCSession) Close() {<span class="cov8" title="1">
        // Do nothing for now
}</span>

// GetProviderDisplayName returns the name of the VPC provider
func (vpcs *VPCSession) GetProviderDisplayName() provider.VolumeProvider <span class="cov8" title="1">{
        return VPC
}</span>

// ProviderName ...
func (vpcs *VPCSession) ProviderName() provider.VolumeProvider <span class="cov8" title="1">{
        return VPC
}</span>

// Type ...
func (vpcs *VPCSession) Type() provider.VolumeType <span class="cov8" title="1">{
        return VolumeType
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "crypto/rsa"
        "errors"
        "io/ioutil"
        "path/filepath"
        "time"

        "github.com/dgrijalva/jwt-go"
        "go.uber.org/zap"

        "github.com/IBM/ibmcloud-volume-interface/config"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/provider/auth"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
)

// tokenGenerator ...
type tokenGenerator struct {
        config *config.VPCProviderConfig

        tokenKID        string
        tokenTTL        time.Duration
        tokenBeforeTime time.Duration

        privateKey *rsa.PrivateKey // Secret. Do not export
}

// readConfig ...
func (tg *tokenGenerator) readConfig(logger zap.Logger) (err error) <span class="cov8" title="1">{
        logger.Info("Entering readConfig")
        defer func() </span><span class="cov8" title="1">{
                logger.Info("Exiting readConfig", zap.Duration("tokenTTL", tg.tokenTTL), zap.Duration("tokenBeforeTime", tg.tokenBeforeTime), zap.String("tokenKID", tg.tokenKID), local.ZapError(err))
        }</span>()

        <span class="cov8" title="1">if tg.privateKey != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">path := filepath.Join(GetEtcPath(), tg.tokenKID)

        pem, err := ioutil.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error reading PEM", local.ZapError(err))
                return
        }</span>

        <span class="cov8" title="1">privateKey, err := jwt.ParseRSAPrivateKeyFromPEM(pem)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error parsing PEM", local.ZapError(err))
                return
        }</span>

        <span class="cov8" title="1">tg.privateKey = privateKey

        return</span>
}

// buildToken ...
func (tg *tokenGenerator) buildToken(contextCredentials provider.ContextCredentials, ts time.Time, logger zap.Logger) (token *jwt.Token, err error) <span class="cov8" title="1">{
        logger.Info("Entering getJWTToken", zap.Reflect("contextCredentials", contextCredentials))
        defer func() </span><span class="cov8" title="1">{
                logger.Info("Exiting getJWTToken", zap.Reflect("token", token), local.ZapError(err))
        }</span>()

        <span class="cov8" title="1">err = tg.readConfig(logger)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">claims := jwt.MapClaims{
                "iss": "armada",
                "exp": ts.Add(tg.tokenTTL).Unix(),
                "nbf": ts.Add(tg.tokenBeforeTime).Unix(),
                "iat": ts.Unix(),
        }

        switch </span>{
        case contextCredentials.UserID == "":<span class="cov8" title="1">
                errStr := "User ID is not configured"
                logger.Error(errStr)
                err = errors.New(errStr)
                return</span>

        case contextCredentials.AuthType == auth.IMSToken:<span class="cov8" title="1">
                claims["ims_user_id"] = contextCredentials.UserID</span>

        default:<span class="cov8" title="1">
                claims["ims_username"] = contextCredentials.UserID</span>
        }

        <span class="cov8" title="1">token = jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        token.Header["kid"] = tg.tokenKID

        return</span>
}

// getServiceToken ...
func (tg *tokenGenerator) getServiceToken(contextCredentials provider.ContextCredentials, logger zap.Logger) (signedToken *string, err error) <span class="cov8" title="1">{
        token, err := tg.buildToken(contextCredentials, time.Now(), logger)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">signedString, err := token.SignedString(tg.privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">signedToken = &amp;signedString

        return</span>
}

// GetEtcPath returns the path to the etc directory
func GetEtcPath() string <span class="cov8" title="1">{
        goPath := config.GetGoPath()
        srcPath := filepath.Join("src", "github.com", "IBM",
                "ibmcloud-volume-vpc")
        return filepath.Join(goPath, srcPath, "etc")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "errors"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
)

// UpdateVolume POSTs to /volumes
func (vpc *VPCSession) UpdateVolume(volumeTemplate provider.Volume) error <span class="cov0" title="0">{
        return errors.New("unsupported Operation")
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "strconv"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// maxRetryAttempt ...
var maxRetryAttempt = 10

// maxRetryGap ...
var maxRetryGap = 60

//ConstantRetryGap ...
const (
        ConstantRetryGap = 10 // seconds
)

var volumeIDPartsCount = 5

var skipErrorCodes = map[string]bool{
        "validation_invalid_name":          true,
        "volume_capacity_max":              true,
        "volume_id_invalid":                true,
        "volume_profile_iops_invalid":      true,
        "volume_capacity_zero_or_negative": true,
        "not_found":                        true,
        "volume_id_not_found":              true,
        "volume_name_not_found":            true,
        "internal_error":                   false,
        "invalid_route":                    false,
        "snapshots_not_found":              true,

        // IKS ms error code for skip re-try
        "ST0008": true, //resources not found
        "ST0005": true, //worker node could not be found
        "ST0014": true, // Required parameter missing or invalid
        "ST0015": true, // Required parameter missing
        "ST0016": true, // Tagging failed .. Do not repeat
        "P4106":  true, // Instnace not found
        "P4107":  true, // Volume not found
        "P4109":  true, // Volume attachment not found
}

// retry ...
func retry(logger *zap.Logger, retryfunc func() error) error <span class="cov8" title="1">{
        var err error
        retryGap := 10
        for i := 0; i &lt; maxRetryAttempt; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(retryGap) * time.Second)
                }</span>
                <span class="cov8" title="1">err = retryfunc()
                if err != nil </span><span class="cov8" title="1">{
                        //Skip retry for the below type of Errors
                        modelError, ok := err.(*models.Error)
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if skipRetry(modelError) </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if i &gt;= 1 </span><span class="cov8" title="1">{
                                retryGap = 2 * retryGap
                                if retryGap &gt; maxRetryGap </span><span class="cov8" title="1">{
                                        retryGap = maxRetryGap
                                }</span>
                        }
                        <span class="cov8" title="1">if (i + 1) &lt; maxRetryAttempt </span><span class="cov8" title="1">{
                                logger.Info("Error while executing the function. Re-attempting execution ..", zap.Int("attempt..", i+2), zap.Int("retry-gap", retryGap), zap.Int("max-retry-Attempts", maxRetryAttempt), zap.Error(err))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">return err</span>
}

// skipRetry skip retry as per listed error codes
func skipRetry(err *models.Error) bool <span class="cov8" title="1">{
        for _, errorItem := range err.Errors </span><span class="cov8" title="1">{
                skipStatus, ok := skipErrorCodes[string(errorItem.Code)]
                if ok </span><span class="cov8" title="1">{
                        return skipStatus
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// SkipRetryForIKS skip retry as per listed error codes
func SkipRetryForIKS(err error) bool <span class="cov0" title="0">{
        iksError, iksok := err.(*models.IksError)
        if iksok </span><span class="cov0" title="0">{
                skipStatus, ok := skipErrorCodes[iksError.Code]
                if ok </span><span class="cov0" title="0">{
                        return skipStatus
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// skipRetryForObviousErrors skip retry as per listed error codes
func skipRetryForObviousErrors(err error, isIKS bool) bool <span class="cov8" title="1">{
        // Only for storage-api ms related calls error
        if isIKS </span><span class="cov0" title="0">{
                return SkipRetryForIKS(err)
        }</span>

        // Only for RIaaS attachment related calls error
        <span class="cov8" title="1">riaasError, ok := err.(*models.Error)
        if ok </span><span class="cov0" title="0">{
                return skipRetry(riaasError)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// FlexyRetry ...
type FlexyRetry struct {
        maxRetryAttempt int
        maxRetryGap     int
}

// NewFlexyRetryDefault ...
func NewFlexyRetryDefault() FlexyRetry <span class="cov8" title="1">{
        return FlexyRetry{
                // Default values as we configuration
                maxRetryAttempt: maxRetryAttempt,
                maxRetryGap:     maxRetryGap,
        }
}</span>

// NewFlexyRetry ...
func NewFlexyRetry(maxRtyAtmpt int, maxrRtyGap int) FlexyRetry <span class="cov0" title="0">{
        return FlexyRetry{
                maxRetryAttempt: maxRtyAtmpt,
                maxRetryGap:     maxrRtyGap,
        }
}</span>

// FlexyRetry ...
func (fRetry *FlexyRetry) FlexyRetry(logger *zap.Logger, funcToRetry func() (error, bool)) error <span class="cov8" title="1">{
        var err error
        var stopRetry bool
        retryGap := 10
        for i := 0; i &lt; fRetry.maxRetryAttempt; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(retryGap) * time.Second)
                }</span>
                // Call function which required retry, retry is decided by function itself
                <span class="cov8" title="1">err, stopRetry = funcToRetry()
                if stopRetry </span><span class="cov8" title="1">{
                        break</span>
                }

                // Update retry gap as per exponentioal
                <span class="cov8" title="1">if i &gt;= 1 </span><span class="cov8" title="1">{
                        retryGap = 2 * retryGap
                        if retryGap &gt; fRetry.maxRetryGap </span><span class="cov8" title="1">{
                                retryGap = fRetry.maxRetryGap
                        }</span>
                }
                <span class="cov8" title="1">if (i + 1) &lt; fRetry.maxRetryAttempt </span><span class="cov8" title="1">{
                        logger.Info("UNEXPECTED RESULT, Re-attempting execution ..", zap.Int("attempt..", i+2),
                                zap.Int("retry-gap", retryGap), zap.Int("max-retry-Attempts", fRetry.maxRetryAttempt),
                                zap.Bool("stopRetry", stopRetry), zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

// FlexyRetryWithConstGap ...
func (fRetry *FlexyRetry) FlexyRetryWithConstGap(logger *zap.Logger, funcToRetry func() (error, bool)) error <span class="cov8" title="1">{
        var err error
        var stopRetry bool
        // lets have more number of try for wait for attach and detach specially
        totalAttempt := fRetry.maxRetryAttempt * 4 // 40 time as per default values i.e 400 seconds
        for i := 0; i &lt; totalAttempt; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        time.Sleep(time.Duration(ConstantRetryGap) * time.Second)
                }</span>
                // Call function which required retry, retry is decided by function itself
                <span class="cov8" title="1">err, stopRetry = funcToRetry()
                if stopRetry </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if (i + 1) &lt; totalAttempt </span><span class="cov8" title="1">{
                        logger.Info("UNEXPECTED RESULT from FlexyRetryWithConstGap, Re-attempting execution ..", zap.Int("attempt..", i+2),
                                zap.Int("retry-gap", ConstantRetryGap), zap.Int("max-retry-Attempts", totalAttempt),
                                zap.Bool("stopRetry", stopRetry), zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

// ToInt ...
func ToInt(valueInInt string) int <span class="cov8" title="1">{
        value, err := strconv.Atoi(valueInInt)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return value</span>
}

// ToInt64 ...
func ToInt64(valueInInt string) int64 <span class="cov8" title="1">{
        value, err := strconv.ParseInt(valueInInt, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return value</span>
}

// FromProviderToLibVolume converting vpc provider volume type to generic lib volume type
func FromProviderToLibVolume(vpcVolume *models.Volume, logger *zap.Logger) (libVolume *provider.Volume) <span class="cov8" title="1">{
        logger.Debug("Entry of FromProviderToLibVolume method...")
        defer logger.Debug("Exit from FromProviderToLibVolume method...")

        if vpcVolume == nil </span><span class="cov0" title="0">{
                logger.Info("Volume details are empty")
                return
        }</span>

        <span class="cov8" title="1">if vpcVolume.Zone == nil </span><span class="cov0" title="0">{
                logger.Info("Volume zone is empty")
                return
        }</span>

        <span class="cov8" title="1">logger.Debug("Volume details of VPC client", zap.Reflect("models.Volume", vpcVolume))

        volumeCap := int(vpcVolume.Capacity)
        iops := strconv.Itoa(int(vpcVolume.Iops))
        var createdDate time.Time
        if vpcVolume.CreatedAt != nil </span><span class="cov8" title="1">{
                createdDate = *vpcVolume.CreatedAt
        }</span>

        <span class="cov8" title="1">libVolume = &amp;provider.Volume{
                VolumeID:     vpcVolume.ID,
                Provider:     VPC,
                Capacity:     &amp;volumeCap,
                Iops:         &amp;iops,
                VolumeType:   VolumeType,
                CreationTime: createdDate,
        }
        if vpcVolume.Zone != nil </span><span class="cov8" title="1">{
                libVolume.Az = vpcVolume.Zone.Name
        }</span>
        <span class="cov8" title="1">libVolume.CRN = vpcVolume.CRN
        return</span>
}

// IsValidVolumeIDFormat validating(gc has 5 parts and NG has 6 parts)
func IsValidVolumeIDFormat(volID string) bool <span class="cov8" title="1">{
        parts := strings.Split(volID, "-")
        return len(parts) &gt;= volumeIDPartsCount
}</span>

// SetRetryParameters sets the retry logic parameters
func SetRetryParameters(maxAttempts int, maxGap int) <span class="cov8" title="1">{
        if maxAttempts &gt; 0 </span><span class="cov8" title="1">{
                maxRetryAttempt = maxAttempts
        }</span>

        <span class="cov8" title="1">if maxGap &gt; 0 </span><span class="cov8" title="1">{
                maxRetryGap = maxGap
        }</span>
}

func roundUpSize(volumeSizeBytes int64, allocationUnitBytes int64) int64 <span class="cov8" title="1">{
        return (volumeSizeBytes + allocationUnitBytes - 1) / allocationUnitBytes
}</span>

// isValidServiceSession check if Service Session is valid
func isValidServiceSession(vpcs *VPCSession) (err error) <span class="cov8" title="1">{
        //If VPC session contains valid SessionError then there is some session related issue
        if vpcs.SessionError != nil </span><span class="cov8" title="1">{
                vpcs.Logger.Warn("Provider session is not valid")
                return userError.GetUserError(string(userError.InvalidServiceSession), vpcs.SessionError)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "go.uber.org/zap"
)

// WaitForAttachVolume waits for volume to be attached to node. e.g waits till status becomes attached
func (vpcs *VPCSession) WaitForAttachVolume(volumeAttachmentTemplate provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForAttachVolume method...")
        defer vpcs.Logger.Debug("Exit from WaitForAttachVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "WaitForAttachVolume", time.Now())
        var err error

        //check if ServiceSession is valid
        if err = isValidServiceSession(vpcs); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Validating basic inputs for WaitForAttachVolume method...", zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate))
        err = vpcs.validateAttachVolumeRequest(volumeAttachmentTemplate)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var currentVolAttachment *provider.VolumeAttachmentResponse
        err = vpcs.APIRetry.FlexyRetryWithConstGap(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                currentVolAttachment, err = vpcs.GetVolumeAttachment(volumeAttachmentTemplate)
                if err != nil </span><span class="cov8" title="1">{
                        // Need to stop retry as there is an error while getting attachment
                        // considering that vpcs.GetVolumeAttachment already re-tried
                        return err, true
                }</span>
                // Stop retry in case of volume is attached
                <span class="cov8" title="1">return err, currentVolAttachment != nil &amp;&amp; currentVolAttachment.Status == StatusAttached</span>
        })
        // Success case, checks are required in case of timeout happened and volume is still not attached state
        <span class="cov8" title="1">if err == nil &amp;&amp; (currentVolAttachment != nil &amp;&amp; currentVolAttachment.Status == StatusAttached) </span><span class="cov8" title="1">{
                return currentVolAttachment, nil
        }</span>

        <span class="cov8" title="1">userErr := userError.GetUserError(string(userError.VolumeAttachTimedOut), nil, volumeAttachmentTemplate.VolumeID, volumeAttachmentTemplate.InstanceID)
        vpcs.Logger.Info("Wait for attach timed out", zap.Error(userErr))

        return nil, userErr</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "go.uber.org/zap"
)

// WaitForDetachVolume waits for volume to be detached from node. e.g waits till no volume attachment is found
func (vpcs *VPCSession) WaitForDetachVolume(volumeAttachmentTemplate provider.VolumeAttachmentRequest) error <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForDetachVolume method...")
        defer vpcs.Logger.Debug("Exit from WaitForDetachVolume method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "WaitForDetachVolume", time.Now())
        var err error

        //check if ServiceSession is valid
        if err = isValidServiceSession(vpcs); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">vpcs.Logger.Info("Validating basic inputs for WaitForDetachVolume method...", zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate))
        err = vpcs.validateAttachVolumeRequest(volumeAttachmentTemplate)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = vpcs.APIRetry.FlexyRetryWithConstGap(vpcs.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                _, err := vpcs.GetVolumeAttachment(volumeAttachmentTemplate)
                // In case of error we should not retry as there are two conditions for error
                // 1- some issues at endpoint side --&gt; Which is already covered in vpcs.GetVolumeAttachment
                // 2- Attachment not found i.e err != nil --&gt; in this case we should not re-try as it has been deleted
                if err != nil </span><span class="cov8" title="1">{
                        return err, true
                }</span>
                <span class="cov8" title="1">return err, false</span>
        })

        // Could be a success case
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if errMsg, ok := err.(util.Message); ok </span><span class="cov8" title="1">{
                        if errMsg.Code == userError.VolumeAttachFindFailed </span><span class="cov8" title="1">{
                                vpcs.Logger.Info("Volume detachment is complete")
                                return nil
                        }</span>
                }
        }

        <span class="cov8" title="1">userErr := userError.GetUserError(string(userError.VolumeDetachTimedOut), err, volumeAttachmentTemplate.VolumeID, volumeAttachmentTemplate.InstanceID)
        vpcs.Logger.Info("Wait for detach timed out", zap.Error(userErr))
        return userErr</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

const (
        validVolumeStatus = "available"
)

// WaitForValidVolumeState checks the volume for valid status
func WaitForValidVolumeState(vpcs *VPCSession, volumeID string) (err error) <span class="cov8" title="1">{
        vpcs.Logger.Debug("Entry of WaitForValidVolumeState method...")
        defer vpcs.Logger.Debug("Exit from WaitForValidVolumeState method...")
        defer metrics.UpdateDurationFromStart(vpcs.Logger, "WaitForValidVolumeState", time.Now())

        vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("VolumeID", volumeID))

        var volume *models.Volume
        err = retry(vpcs.Logger, func() error </span><span class="cov8" title="1">{
                volume, err = vpcs.Apiclient.VolumeService().GetVolume(volumeID, vpcs.Logger)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">vpcs.Logger.Info("Getting volume details from VPC provider...", zap.Reflect("volume", volume))
                if volume != nil &amp;&amp; volume.Status == validVolumeStatus </span><span class="cov8" title="1">{
                        vpcs.Logger.Info("Volume got valid (available) state", zap.Reflect("VolumeDetails", volume))
                        return nil
                }</span>
                <span class="cov8" title="1">return userError.GetUserError("VolumeNotInValidState", err, volumeID)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                vpcs.Logger.Info("Volume could not get valid (available) state", zap.Reflect("VolumeDetails", volume))
                return userError.GetUserError("VolumeNotInValidState", err, volumeID)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package auth ...
package auth

import (
        "github.com/IBM/ibmcloud-volume-interface/provider/auth"
        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        vpcconfig "github.com/IBM/ibmcloud-volume-vpc/block/vpcconfig"
        vpciam "github.com/IBM/ibmcloud-volume-vpc/common/iam"
)

// NewVPCContextCredentialsFactory ...
func NewVPCContextCredentialsFactory(config *vpcconfig.VPCBlockConfig) (*auth.ContextCredentialsFactory, error) <span class="cov8" title="1">{
        authConfig := &amp;iam.AuthConfiguration{
                IamURL:          config.VPCConfig.TokenExchangeURL,
                IamClientID:     config.VPCConfig.IamClientID,
                IamClientSecret: config.VPCConfig.IamClientSecret,
        }
        ccf, err := auth.NewContextCredentialsFactory(authConfig)
        if config.VPCConfig.IKSTokenExchangePrivateURL != "" </span><span class="cov0" title="0">{
                authIKSConfig := &amp;vpciam.IksAuthConfiguration{
                        IamAPIKey:       config.VPCConfig.APIKey,
                        PrivateAPIRoute: config.VPCConfig.IKSTokenExchangePrivateURL, // Only for private cluster
                        CSRFToken:       config.APIConfig.PassthroughSecret,          // required for private cluster
                }
                ccf.TokenExchangeService, err = vpciam.NewTokenExchangeIKSService(authIKSConfig)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ccf, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package iam ...
package iam

import (
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/IBM-Cloud/ibm-cloud-cli-sdk/common/rest"
        "github.com/IBM/ibmcloud-volume-interface/config"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        "go.uber.org/zap"
)

// tokenExchangeIKSService ...
type tokenExchangeIKSService struct {
        iksAuthConfig *IksAuthConfiguration
        httpClient    *http.Client
}

// IksAuthConfiguration ...
type IksAuthConfiguration struct {
        PrivateAPIRoute string
        IamAPIKey       string
        CSRFToken       string
}

// TokenExchangeService ...
var _ iam.TokenExchangeService = &amp;tokenExchangeIKSService{}

// NewTokenExchangeIKSService ...
func NewTokenExchangeIKSService(iksAuthConfig *IksAuthConfiguration) (iam.TokenExchangeService, error) <span class="cov8" title="1">{
        httpClient, err := config.GeneralCAHttpClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;tokenExchangeIKSService{
                iksAuthConfig: iksAuthConfig,
                httpClient:    httpClient,
        }, nil</span>
}

// tokenExchangeIKSRequest ...
type tokenExchangeIKSRequest struct {
        tes          *tokenExchangeIKSService
        request      *rest.Request
        client       *rest.Client
        logger       *zap.Logger
        errorRetrier *util.ErrorRetrier
}

// tokenExchangeIKSResponse ...
type tokenExchangeIKSResponse struct {
        AccessToken string `json:"token"`
        //ImsToken    string `json:"ims_token"`
}

// ExchangeRefreshTokenForAccessToken ...
func (tes *tokenExchangeIKSService) ExchangeRefreshTokenForAccessToken(refreshToken string, logger *zap.Logger) (*iam.AccessToken, error) <span class="cov8" title="1">{
        r := tes.newTokenExchangeRequest(logger)
        return r.exchangeForAccessToken()
}</span>

// ExchangeIAMAPIKeyForAccessToken ...
func (tes *tokenExchangeIKSService) ExchangeIAMAPIKeyForAccessToken(iamAPIKey string, logger *zap.Logger) (*iam.AccessToken, error) <span class="cov8" title="1">{
        r := tes.newTokenExchangeRequest(logger)
        return r.exchangeForAccessToken()
}</span>

// newTokenExchangeRequest ...
func (tes *tokenExchangeIKSService) newTokenExchangeRequest(logger *zap.Logger) *tokenExchangeIKSRequest <span class="cov8" title="1">{
        client := rest.NewClient()
        client.HTTPClient = tes.httpClient
        retyrInterval, _ := time.ParseDuration("3s")
        return &amp;tokenExchangeIKSRequest{
                tes:          tes,
                request:      rest.PostRequest(fmt.Sprintf("%s/v1/iam/apikey", tes.iksAuthConfig.PrivateAPIRoute)),
                client:       client,
                logger:       logger,
                errorRetrier: util.NewErrorRetrier(40, retyrInterval, logger),
        }
}</span>

// ExchangeAccessTokenForIMSToken ...
func (tes *tokenExchangeIKSService) ExchangeAccessTokenForIMSToken(accessToken iam.AccessToken, logger *zap.Logger) (*iam.IMSToken, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// ExchangeIAMAPIKeyForIMSToken ...
func (tes *tokenExchangeIKSService) ExchangeIAMAPIKeyForIMSToken(iamAPIKey string, logger *zap.Logger) (*iam.IMSToken, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (tes *tokenExchangeIKSService) GetIAMAccountIDFromAccessToken(accessToken iam.AccessToken, logger *zap.Logger) (accountID string, err error) <span class="cov0" title="0">{
        return "Not required to implement", nil
}</span>

// exchangeForAccessToken ...
func (r *tokenExchangeIKSRequest) exchangeForAccessToken() (*iam.AccessToken, error) <span class="cov8" title="1">{
        var iamResp *tokenExchangeIKSResponse
        var err error
        err = r.errorRetrier.ErrorRetry(func() (error, bool) </span><span class="cov8" title="1">{
                iamResp, err = r.sendTokenExchangeRequest()
                return err, !iam.IsConnectionError(err) // Skip retry if its not connection error
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;iam.AccessToken{Token: iamResp.AccessToken}, nil</span>
}

// sendTokenExchangeRequest ...
func (r *tokenExchangeIKSRequest) sendTokenExchangeRequest() (*tokenExchangeIKSResponse, error) <span class="cov8" title="1">{
        r.logger.Info("In tokenExchangeIKSRequest's sendTokenExchangeRequest()")
        // Set headers
        r.request = r.request.Add("X-CSRF-TOKEN", r.tes.iksAuthConfig.CSRFToken)
        // Setting body
        var apikey = struct {
                APIKey string `json:"apikey"`
        }{
                APIKey: r.tes.iksAuthConfig.IamAPIKey,
        }
        r.request = r.request.Body(&amp;apikey)

        var successV tokenExchangeIKSResponse
        var errorV = struct {
                ErrorCode        string `json:"code"`
                ErrorDescription string `json:"description"`
                ErrorType        string `json:"type"`
                IncidentID       string `json:"incidentID"`
        }{}

        r.logger.Info("Sending IAM token exchange request to container api server")
        resp, err := r.client.Do(r.request, &amp;successV, &amp;errorV)
        if err != nil </span><span class="cov8" title="1">{
                errString := err.Error()
                r.logger.Error("IAM token exchange request failed", zap.Reflect("Response", resp), zap.Error(err))
                if strings.Contains(errString, "no such host") </span><span class="cov0" title="0">{
                        return nil, util.NewError("EndpointNotReachable", errString)
                }</span> else<span class="cov8" title="1"> if strings.Contains(errString, "Timeout") </span><span class="cov0" title="0">{
                        return nil, util.NewError("Timeout", errString)
                }</span> else<span class="cov8" title="1"> {
                        return nil, util.NewError("ErrorUnclassified",
                                "IAM token exchange request failed", err)
                }</span>
        }

        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode == 200 </span><span class="cov8" title="1">{
                r.logger.Debug("IAM token exchange request successful")
                return &amp;successV, nil
        }</span>
        // closing resp body only when some issues, in case of success its not required
        // to close here
        <span class="cov8" title="1">defer resp.Body.Close()

        if errorV.ErrorDescription != "" </span><span class="cov8" title="1">{
                r.logger.Error("IAM token exchange request failed with message",
                        zap.Int("StatusCode", resp.StatusCode), zap.Reflect("API IncidentID", errorV.IncidentID),
                        zap.Reflect("Error", errorV))

                err := util.NewError("ErrorFailedTokenExchange",
                        "IAM token exchange request failed: "+errorV.ErrorDescription,
                        errors.New(errorV.ErrorCode+" "+errorV.ErrorType+", Description: "+errorV.ErrorDescription+", API IncidentID:"+errorV.IncidentID))
                return nil, err
        }</span>

        <span class="cov8" title="1">r.logger.Error("Unexpected IAM token exchange response",
                zap.Int("StatusCode", resp.StatusCode), zap.Reflect("Response", resp))

        return nil,
                util.NewError("ErrorUnclassified",
                        "Unexpected IAM token exchange response")</span>
}

// UpdateAPIKey ...
func (tes *tokenExchangeIKSService) UpdateAPIKey(apiKey string, logger *zap.Logger) error <span class="cov8" title="1">{
        logger.Info("Updating api key")
        if tes.iksAuthConfig == nil </span><span class="cov8" title="1">{
                return errors.New("failed to update api key")
        }</span>
        <span class="cov8" title="1">tes.iksAuthConfig.IamAPIKey = apiKey
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

import (
        "errors"
)

// ErrAuthenticationRequired is returned if a request is made before an authentication
// token has been provided to the client
var ErrAuthenticationRequired = errors.New("authentication token required")

type authenticationHandler struct {
        authToken     string
        resourceGroup string
}

// Before is called before each request
func (a *authenticationHandler) Before(request *Request) error <span class="cov8" title="1">{
        request.resourceGroup = a.resourceGroup

        if a.authToken == "" </span><span class="cov0" title="0">{
                return ErrAuthenticationRequired
        }</span>
        <span class="cov8" title="1">request.headers.Set("Authorization", "Bearer "+a.authToken)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

import (
        "context"
        "io"
        "net/http"
        "net/url"

        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
)

// handler ...
type handler interface {
        Before(request *Request) error
}

// SessionClient provides an interface for a REST API client
// go:generate counterfeiter -o fakes/client.go --fake-name SessionClient . SessionClient
type SessionClient interface {
        NewRequest(operation *Operation) *Request
        WithDebug(writer io.Writer) SessionClient
        WithAuthToken(authToken string) SessionClient
        WithPathParameter(name, value string) SessionClient
        WithQueryValue(name, value string) SessionClient
}

type client struct {
        baseURL       string
        httpClient    *http.Client
        pathParams    Params
        queryValues   url.Values
        authenHandler handler
        debugWriter   io.Writer
        resourceGroup string
        contextID     string
        context       context.Context
}

// New creates a new instance of a SessionClient
func New(ctx context.Context, baseURL string, queryValues url.Values, httpClient *http.Client, contextID string, resourceGroupID string) SessionClient <span class="cov8" title="1">{
        return &amp;client{
                baseURL:       baseURL,
                httpClient:    httpClient,
                pathParams:    Params{},
                queryValues:   queryValues,
                authenHandler: &amp;authenticationHandler{},
                contextID:     contextID,
                context:       ctx,
                resourceGroup: resourceGroupID,
        }
}</span>

// NewRequest creates a request and configures it with the supplied operation
func (c *client) NewRequest(operation *Operation) *Request <span class="cov8" title="1">{
        headers := http.Header{}
        headers.Set("Accept", "application/json")
        headers.Set("User-Agent", models.UserAgent)
        if c.contextID != "" </span><span class="cov8" title="1">{
                headers.Set("X-Request-ID", c.contextID)
                headers.Set("X-Transaction-ID", c.contextID) // To avoid IKS cloudflare overriding X-Request-ID
        }</span>

        <span class="cov8" title="1">if c.resourceGroup != "" </span><span class="cov8" title="1">{
                headers.Set("X-Auth-Resource-Group-ID", c.resourceGroup)
        }</span>

        // Copy the query values to a new map
        <span class="cov8" title="1">qv := url.Values{}
        for k, v := range c.queryValues </span><span class="cov8" title="1">{
                qv[k] = v
        }</span>

        <span class="cov8" title="1">return &amp;Request{
                httpClient:    c.httpClient,
                context:       c.context,
                baseURL:       c.baseURL,
                operation:     operation,
                pathParams:    c.pathParams.Copy(),
                authenHandler: c.authenHandler,
                headers:       headers,
                debugWriter:   c.debugWriter,
                resourceGroup: c.resourceGroup,
                queryValues:   qv,
        }</span>
}

// WithDebug enables debug for this SessionClient, outputting to the supplied writer
func (c *client) WithDebug(writer io.Writer) SessionClient <span class="cov8" title="1">{
        c.debugWriter = writer
        return c
}</span>

// WithAuthToken supplies the authentication token to use for all requests made by this session
func (c *client) WithAuthToken(authToken string) SessionClient <span class="cov8" title="1">{
        c.authenHandler = &amp;authenticationHandler{
                authToken: authToken,
        }
        return c
}</span>

// WithPathParameter adds a path parameter to the request
func (c *client) WithPathParameter(name, value string) SessionClient <span class="cov8" title="1">{
        c.pathParams[name] = value
        return c
}</span>

// WithQueryValue adds a query parameter to the request
func (c *client) WithQueryValue(name, value string) SessionClient <span class="cov8" title="1">{
        c.queryValues.Set(name, value)
        return c
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

// Params ...
type Params map[string]string

// Copy performs a shallow copy of a Params object
func (p Params) Copy() Params <span class="cov8" title="1">{
        params := Params{}
        for k, v := range p </span><span class="cov8" title="1">{
                params[k] = v
        }</span>
        <span class="cov8" title="1">return params</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package client ...
package client

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/http/httputil"
        "net/url"
        "reflect"
        "regexp"
        "strings"
        "time"

        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client/payload"
        "github.com/fatih/structs"
)

// Operation defines the API operation to be invoked
type Operation struct {
        Name        string
        Method      string
        PathPattern string
}

// Request defines the properties of an API request. It can then be invoked to
// call the underlying API specified by the supplied operation
type Request struct {
        httpClient    *http.Client
        baseURL       string
        authenHandler handler

        context context.Context

        operation  *Operation
        pathParams Params
        headers    http.Header

        debugWriter io.Writer

        queryValues     url.Values
        bodyProvider    BodyProvider
        successConsumer ResponseConsumer
        errorConsumer   ResponseConsumer
        resourceGroup   string
}

// BodyProvider declares an interface that describes an HTTP body, for
// both request and response
type BodyProvider interface {
        ContentType() string
        Body() (io.Reader, error)
}

// ResponseConsumer ...
type ResponseConsumer interface {
        Consume(io.Reader) error
        Receiver() interface{}
}

func (r *Request) path() string <span class="cov8" title="1">{
        path := r.operation.PathPattern
        for k, v := range r.pathParams </span><span class="cov0" title="0">{
                path = strings.Replace(path, "{"+k+"}", v, -1)
        }</span>
        <span class="cov8" title="1">return path</span>
}

// URL constructs the full URL for a request
func (r *Request) URL() string <span class="cov8" title="1">{
        baseURL, baseErr := url.Parse(r.baseURL)
        if baseErr != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(baseURL.Path, "/") </span><span class="cov8" title="1">{
                baseURL.Path += "/"
        }</span>
        <span class="cov8" title="1">pathURL, pathErr := url.Parse(r.path())
        if pathErr != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">resolvedURL := baseURL.ResolveReference(pathURL)
        resolvedURL.RawQuery = r.queryValues.Encode()

        return resolvedURL.String()</span>
}

// PathParameter sets a path parameter to be resolved on invocation of a request
func (r *Request) PathParameter(name, value string) *Request <span class="cov0" title="0">{
        r.pathParams[name] = value
        return r
}</span>

// AddQueryValue ...
func (r *Request) AddQueryValue(key, value string) *Request <span class="cov8" title="1">{
        if r.queryValues == nil </span><span class="cov0" title="0">{
                r.queryValues = url.Values{}
        }</span>
        <span class="cov8" title="1">r.queryValues.Add(key, value)
        return r</span>
}

// SetQueryValue ...
func (r *Request) SetQueryValue(key, value string) *Request <span class="cov0" title="0">{
        if r.queryValues == nil </span><span class="cov0" title="0">{
                r.queryValues = url.Values{}
        }</span>
        <span class="cov0" title="0">r.queryValues.Set(key, value)
        return r</span>
}

// JSONBody converts the supplied argument to JSON to use as the body of a request
func (r *Request) JSONBody(p interface{}) *Request <span class="cov8" title="1">{
        if r.operation.Method == http.MethodPost &amp;&amp; reflect.ValueOf(p).Kind() == reflect.Struct </span><span class="cov0" title="0">{
                structs.DefaultTagName = "json"
                m := structs.Map(p)

                if r.resourceGroup != "" </span><span class="cov0" title="0">{
                        m["resourceGroup"] = r.resourceGroup
                }</span>

                <span class="cov0" title="0">r.bodyProvider = payload.NewJSONBodyProvider(m)</span>
        } else<span class="cov8" title="1"> {
                r.bodyProvider = payload.NewJSONBodyProvider(p)
        }</span>
        <span class="cov8" title="1">return r</span>
}

// MultipartFileBody configures the POST payload to be sent in multi-part format. The
// content is read from the supplied Reader.
func (r *Request) MultipartFileBody(name string, contents io.Reader) *Request <span class="cov8" title="1">{
        r.bodyProvider = payload.NewMultipartFileBody(name, contents)
        return r
}</span>

// JSONSuccess configures the receiver to use to process a JSON response
// for a successful (2xx) response
func (r *Request) JSONSuccess(receiver interface{}) *Request <span class="cov8" title="1">{
        r.successConsumer = payload.NewJSONConsumer(receiver)
        return r
}</span>

// JSONError configures the error to populate in the event of an unsuccessful
// (non-2xx) response
func (r *Request) JSONError(receiver error) *Request <span class="cov8" title="1">{
        r.errorConsumer = payload.NewJSONConsumer(receiver)
        return r
}</span>

// Invoke performs the request, and populates the response or error as appropriate
func (r *Request) Invoke() (*http.Response, error) <span class="cov8" title="1">{
        err := r.authenHandler.Before(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var body io.Reader
        if r.bodyProvider != nil </span><span class="cov8" title="1">{
                body, err = r.bodyProvider.Body()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if contentType := r.bodyProvider.ContentType(); contentType != "" </span><span class="cov8" title="1">{
                        r.headers.Set("Content-Type", contentType)
                }</span>
        }

        <span class="cov8" title="1">httpRequest, err := http.NewRequest(r.operation.Method, r.URL(), body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for k, v := range r.headers </span><span class="cov8" title="1">{
                httpRequest.Header[k] = v
        }</span>

        <span class="cov8" title="1">r.debugRequest(httpRequest)

        resp, err := r.httpClient.Do(httpRequest.WithContext(r.context))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        r.debugResponse(resp)

        switch </span>{
        case resp.StatusCode == http.StatusNoContent:<span class="cov0" title="0">
                break</span>

        case resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt;= 299:<span class="cov8" title="1">
                if r.successConsumer != nil </span><span class="cov8" title="1">{
                        err = r.successConsumer.Consume(resp.Body)
                }</span>

        default:<span class="cov8" title="1">
                if r.errorConsumer != nil </span><span class="cov8" title="1">{
                        err = r.errorConsumer.Consume(resp.Body)
                        if err == nil </span><span class="cov8" title="1">{
                                err = r.errorConsumer.Receiver().(error)
                        }</span>
                }
        }

        <span class="cov8" title="1">return resp, err</span>
}

func (r *Request) debugRequest(req *http.Request) <span class="cov8" title="1">{
        if r.debugWriter == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">multipart := strings.Contains(req.Header.Get("Content-Type"), "multipart/form-data")
        dumpedRequest, err := httputil.DumpRequest(req, !multipart)
        if err != nil </span><span class="cov0" title="0">{
                r.debugf("Error dumping request\n%s\n", err)
                return
        }</span>

        <span class="cov8" title="1">r.debugf("\nREQUEST: [%s]\n%s\n", time.Now().Format(time.RFC3339), sanitize(dumpedRequest))
        if multipart </span><span class="cov8" title="1">{
                r.debugf("[MULTIPART/FORM-DATA CONTENT HIDDEN]\n")
        }</span>
}

func (r *Request) debugResponse(resp *http.Response) <span class="cov8" title="1">{
        if r.debugWriter == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">dumpedResponse, err := httputil.DumpResponse(resp, true)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(r.debugWriter, "Error dumping response\n%s\n", err)
                return
        }</span>

        <span class="cov8" title="1">r.debugf("\nRESPONSE: [%s]\n%s\n", time.Now().Format(time.RFC3339), sanitize(dumpedResponse))</span>
}

func (r *Request) debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintf(r.debugWriter, format, args...)
}</span>

// RedactedFillin used as a replacement string in debug logs for sensitive data
const RedactedFillin = "[REDACTED]"

func sanitize(input []byte) string <span class="cov8" title="1">{
        sanitized := string(input)

        re := regexp.MustCompile(`(?mi)^Authorization: .*`)
        sanitized = re.ReplaceAllString(sanitized, "Authorization: "+RedactedFillin)

        re = regexp.MustCompile(`(?mi)^X-Auth-Token: .*`)
        sanitized = re.ReplaceAllString(sanitized, "X-Auth-Token: "+RedactedFillin)

        re = regexp.MustCompile(`(?mi)^APIKey: .*`)
        sanitized = re.ReplaceAllString(sanitized, "APIKey: "+RedactedFillin)

        sanitized = sanitizeJSON("key", sanitized)
        sanitized = sanitizeJSON("password", sanitized)
        sanitized = sanitizeJSON("passphrase", sanitized)

        return sanitized
}</span>

func sanitizeJSON(propertySubstring string, json string) string <span class="cov8" title="1">{
        regex := regexp.MustCompile(fmt.Sprintf(`(?i)"([^"]*%s[^"]*)":\s*"[^\,]*"`, propertySubstring))
        return regex.ReplaceAllString(json, fmt.Sprintf(`"$1":"%s"`, RedactedFillin))
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// AttachVolume attached volume to instances with givne volume attachment details
func (vs *VolumeAttachService) AttachVolume(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*models.VolumeAttachment, error) <span class="cov8" title="1">{
        methodName := "VolumeAttachService.AttachVolume"
        defer util.TimeTracker(methodName, time.Now())
        defer metrics.UpdateDurationFromStart(ctxLogger, methodName, time.Now())

        operation := &amp;client.Operation{
                Name:        "AttachVolume",
                Method:      "POST",
                PathPattern: vs.pathPrefix + instanceIDvolumeAttachmentPath,
        }

        var volumeAttachment models.VolumeAttachment
        apiErr := vs.receiverError

        operationRequest := vs.client.NewRequest(operation)

        ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", operationRequest.URL()), zap.Reflect("Payload", volumeAttachmentTemplate), zap.Reflect("Operation", operation), zap.Reflect("PathParameters", volumeAttachmentTemplate.InstanceID))
        _, err := vs.populatePathPrefixParameters(operationRequest, volumeAttachmentTemplate).JSONBody(volumeAttachmentTemplate).JSONSuccess(&amp;volumeAttachment).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ctxLogger.Info("Successfully attached the volume")
        return &amp;volumeAttachment, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "net/http"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DetachVolume retrives the volume attach status with givne volume attachment details
func (vs *VolumeAttachService) DetachVolume(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*http.Response, error) <span class="cov8" title="1">{
        methodName := "VolumeAttachService.DetachVolume"
        defer util.TimeTracker(methodName, time.Now())
        defer metrics.UpdateDurationFromStart(ctxLogger, methodName, time.Now())

        operation := &amp;client.Operation{
                Name:        "DetachVolume",
                Method:      "DELETE",
                PathPattern: vs.pathPrefix + instanceIDattachmentIDPath,
        }

        apiErr := vs.receiverError

        operationRequest := vs.client.NewRequest(operation)
        operationRequest = vs.populatePathPrefixParameters(operationRequest, volumeAttachmentTemplate)
        operationRequest = operationRequest.PathParameter(attachmentIDParam, volumeAttachmentTemplate.ID)

        ctxLogger.Info("Equivalent curl command details", zap.Reflect("URL", operationRequest.URL()), zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate), zap.Reflect("Operation", operation))
        ctxLogger.Info("Pathparameters", zap.Reflect(instanceIDParam, volumeAttachmentTemplate.InstanceID), zap.Reflect(attachmentIDParam, volumeAttachmentTemplate.ID))

        resp, err := operationRequest.JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Error occurred while deleting volume attachment", zap.Error(err))
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        // volume Attachment is deleted. So do not want to retry
                        ctxLogger.Info("Exit DetachVolume", zap.Any("resp", resp.StatusCode), zap.Error(err), zap.Error(apiErr))
                        return resp, apiErr
                }</span>
        }
        <span class="cov8" title="1">ctxLogger.Info("Exit DetachVolume", zap.Error(err), zap.Error(apiErr))
        return resp, err</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GetVolumeAttachment retrives the volume attach status with given volume attachment details
func (vs *VolumeAttachService) GetVolumeAttachment(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*models.VolumeAttachment, error) <span class="cov8" title="1">{
        methodName := "VolumeAttachService.GetVolumeAttachment"
        defer util.TimeTracker(methodName, time.Now())
        defer metrics.UpdateDurationFromStart(ctxLogger, methodName, time.Now())

        operation := &amp;client.Operation{
                Name:        "GetVolumeAttachment",
                Method:      "GET",
                PathPattern: vs.pathPrefix + instanceIDattachmentIDPath,
        }

        apiErr := vs.receiverError
        var volumeAttachment models.VolumeAttachment
        operationRequest := vs.client.NewRequest(operation)

        ctxLogger.Info("Equivalent curl command details", zap.Reflect("URL", operationRequest.URL()), zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate), zap.Reflect("Operation", operation))
        ctxLogger.Info("Pathparameters", zap.Reflect(instanceIDParam, volumeAttachmentTemplate.InstanceID), zap.Reflect(attachmentIDParam, volumeAttachmentTemplate.ID))
        operationRequest = vs.populatePathPrefixParameters(operationRequest, volumeAttachmentTemplate)
        operationRequest = operationRequest.PathParameter(attachmentIDParam, volumeAttachmentTemplate.ID)

        _, err := operationRequest.JSONSuccess(&amp;volumeAttachment).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error occurred while getting volume attachment", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">ctxLogger.Info("Successfully retrieved the volume attachment", zap.Reflect("volumeAttachment", volumeAttachment))
        return &amp;volumeAttachment, err</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// AttachVolume attached volume to instances with givne volume attachment details
func (vs *IKSVolumeAttachService) AttachVolume(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*models.VolumeAttachment, error) <span class="cov8" title="1">{
        defer util.TimeTracker("IKS AttachVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "AttachVolume",
                Method:      "POST",
                PathPattern: vs.pathPrefix + "createAttachment",
        }

        var volumeAttachment models.VolumeAttachment
        apiErr := vs.receiverError

        operationRequest := vs.client.NewRequest(operation)

        operationRequest = operationRequest.SetQueryValue(IksClusterQueryKey, *volumeAttachmentTemplate.ClusterID)
        operationRequest = operationRequest.SetQueryValue(IksWorkerQueryKey, *volumeAttachmentTemplate.InstanceID)
        vol := *volumeAttachmentTemplate.Volume
        operationRequest = operationRequest.SetQueryValue(IksVolumeQueryKey, vol.ID)

        ctxLogger.Info("Equivalent curl command and query parameters", zap.Reflect("URL", operationRequest.URL()), zap.Reflect("Payload", volumeAttachmentTemplate), zap.Reflect("Operation", operation), zap.Reflect(IksClusterQueryKey, volumeAttachmentTemplate.ClusterID), zap.Reflect(IksWorkerQueryKey, volumeAttachmentTemplate.InstanceID), zap.Reflect(IksVolumeQueryKey, vol.ID))

        _, err := operationRequest.JSONBody(volumeAttachmentTemplate).JSONSuccess(&amp;volumeAttachment).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ctxLogger.Info("Successfully attached the volume")
        return &amp;volumeAttachment, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "net/http"
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DetachVolume retrives the volume attach status with givne volume attachment details
func (vs *IKSVolumeAttachService) DetachVolume(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*http.Response, error) <span class="cov8" title="1">{
        defer util.TimeTracker("IKS DetachVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "DetachVolume",
                Method:      "DELETE",
                PathPattern: vs.pathPrefix + "deleteAttachment",
        }

        apiErr := vs.receiverError

        operationRequest := vs.client.NewRequest(operation)
        operationRequest = operationRequest.SetQueryValue(IksClusterQueryKey, *volumeAttachmentTemplate.ClusterID)
        operationRequest = operationRequest.SetQueryValue(IksWorkerQueryKey, *volumeAttachmentTemplate.InstanceID)
        operationRequest = operationRequest.SetQueryValue(IksVolumeAttachmentIDQueryKey, volumeAttachmentTemplate.ID)

        ctxLogger.Info("Equivalent curl command and query parameters", zap.Reflect("URL", operationRequest.URL()), zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate), zap.Reflect("Operation", operation), zap.Reflect(IksClusterQueryKey, *volumeAttachmentTemplate.ClusterID), zap.Reflect(IksWorkerQueryKey, *volumeAttachmentTemplate.InstanceID), zap.Reflect(IksVolumeAttachmentIDQueryKey, volumeAttachmentTemplate.ID))

        resp, err := operationRequest.JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error occurred while deleting volume attachment", zap.Error(err))
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        // volume attachment is deleted, no need to retry
                        return resp, apiErr
                }</span>
        }

        <span class="cov8" title="1">ctxLogger.Info("Successfully deleted the volume attachment")
        return resp, err</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GetVolumeAttachment retrives the volume attach status with given volume attachment details
func (vs *IKSVolumeAttachService) GetVolumeAttachment(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*models.VolumeAttachment, error) <span class="cov8" title="1">{
        defer util.TimeTracker("IKS GetVolumeAttachment", time.Now())

        operation := &amp;client.Operation{
                Name:        "GetVolumeAttachment",
                Method:      "GET",
                PathPattern: vs.pathPrefix + "getAttachment",
        }

        apiErr := vs.receiverError
        var volumeAttachment models.VolumeAttachment

        operationRequest := vs.client.NewRequest(operation)
        operationRequest = operationRequest.SetQueryValue(IksClusterQueryKey, *volumeAttachmentTemplate.ClusterID)
        operationRequest = operationRequest.SetQueryValue(IksWorkerQueryKey, *volumeAttachmentTemplate.InstanceID)
        operationRequest = operationRequest.SetQueryValue(IksVolumeAttachmentIDQueryKey, volumeAttachmentTemplate.ID)

        ctxLogger.Info("Equivalent curl command and query parameters", zap.Reflect("URL", operationRequest.URL()), zap.Reflect(IksClusterQueryKey, *volumeAttachmentTemplate.ClusterID), zap.Reflect(IksWorkerQueryKey, *volumeAttachmentTemplate.InstanceID), zap.Reflect(IksVolumeAttachmentIDQueryKey, volumeAttachmentTemplate.ID))

        _, err := operationRequest.JSONSuccess(&amp;volumeAttachment).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error occurred while getting volume attachment", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">ctxLogger.Info("Successfully retrieved the volume attachment", zap.Reflect("volumeAttachment", volumeAttachment))
        return &amp;volumeAttachment, err</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ListVolumeAttachments retrives the list volume attachments with givne volume attachment details
func (vs *IKSVolumeAttachService) ListVolumeAttachments(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*models.VolumeAttachmentList, error) <span class="cov8" title="1">{
        defer util.TimeTracker("IKS ListVolumeAttachments", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListVolumeAttachment",
                Method:      "GET",
                PathPattern: vs.pathPrefix + "getAttachmentsList",
        }

        var volumeAttachmentList models.VolumeAttachmentList

        apiErr := vs.receiverError
        vs.client = vs.client.WithQueryValue(IksClusterQueryKey, *volumeAttachmentTemplate.ClusterID)
        vs.client = vs.client.WithQueryValue(IksWorkerQueryKey, *volumeAttachmentTemplate.InstanceID)

        operationRequest := vs.client.NewRequest(operation)

        ctxLogger.Info("Equivalent curl command and query parameters", zap.Reflect("URL", operationRequest.URL()), zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate), zap.Reflect("Operation", operation), zap.Reflect(IksClusterQueryKey, *volumeAttachmentTemplate.ClusterID), zap.Reflect(IksWorkerQueryKey, *volumeAttachmentTemplate.InstanceID))

        _, err := operationRequest.JSONSuccess(&amp;volumeAttachmentList).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error occurred while getting volume attachments list", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">ctxLogger.Info("Successfully retrieved the volume attachments")
        return &amp;volumeAttachmentList, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ListVolumeAttachments retrives the list volume attachments with givne volume attachment details
func (vs *VolumeAttachService) ListVolumeAttachments(volumeAttachmentTemplate *models.VolumeAttachment, ctxLogger *zap.Logger) (*models.VolumeAttachmentList, error) <span class="cov8" title="1">{
        methodName := "VolumeAttachService.ListVolumeAttachments"
        defer util.TimeTracker(methodName, time.Now())
        defer metrics.UpdateDurationFromStart(ctxLogger, methodName, time.Now())

        operation := &amp;client.Operation{
                Name:        "ListVolumeAttachment",
                Method:      "GET",
                PathPattern: vs.pathPrefix + instanceIDvolumeAttachmentPath,
        }

        var volumeAttachmentList models.VolumeAttachmentList
        apiErr := vs.receiverError

        operationRequest := vs.client.NewRequest(operation)

        ctxLogger.Info("Equivalent curl command details", zap.Reflect("URL", operationRequest.URL()), zap.Reflect("volumeAttachmentTemplate", volumeAttachmentTemplate), zap.Reflect("Operation", operation))
        operationRequest = vs.populatePathPrefixParameters(operationRequest, volumeAttachmentTemplate)

        _, err := operationRequest.JSONSuccess(&amp;volumeAttachmentList).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Error occurred while getting volume attachments list", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">ctxLogger.Info("Successfully retrieved the volume attachments")
        return &amp;volumeAttachmentList, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package instances ...
package instances

import (
        "net/http"

        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// VolumeAttachManager operations
//go:generate counterfeiter -o fakes/volume_attach_service.go --fake-name VolumeAttachService . VolumeAttachManager
type VolumeAttachManager interface {
        // Create the volume with authorisation by passing required information in the volume object
        AttachVolume(*models.VolumeAttachment, *zap.Logger) (*models.VolumeAttachment, error)
        // GetVolumeAttachment retrives the single VolumeAttachment based on the instance ID and attachmentID
        GetVolumeAttachment(*models.VolumeAttachment, *zap.Logger) (*models.VolumeAttachment, error)
        // ListVolumeAttachments retrives the VolumeAttachment list for given server
        ListVolumeAttachments(*models.VolumeAttachment, *zap.Logger) (*models.VolumeAttachmentList, error)
        // Delete the volume
        DetachVolume(*models.VolumeAttachment, *zap.Logger) (*http.Response, error)
}

// VolumeAttachService ...
type VolumeAttachService struct {
        client                       client.SessionClient
        pathPrefix                   string
        receiverError                error
        populatePathPrefixParameters func(request *client.Request, volumeAttachmentTemplate *models.VolumeAttachment) *client.Request
}

// IKSVolumeAttachService ...
type IKSVolumeAttachService struct {
        client        client.SessionClient
        pathPrefix    string
        receiverError error
}

var _ VolumeAttachManager = &amp;VolumeAttachService{}

// New ...
func New(clientIn client.SessionClient) VolumeAttachManager <span class="cov8" title="1">{
        err := models.Error{}
        return &amp;VolumeAttachService{
                client:        clientIn,
                pathPrefix:    VpcPathPrefix,
                receiverError: &amp;err,
                populatePathPrefixParameters: func(request *client.Request, volumeAttachmentTemplate *models.VolumeAttachment) *client.Request </span><span class="cov8" title="1">{
                        request.PathParameter(instanceIDParam, *volumeAttachmentTemplate.InstanceID)
                        return request
                }</span>,
        }
}

var _ VolumeAttachManager = &amp;IKSVolumeAttachService{}

// NewIKSVolumeAttachmentManager ...
func NewIKSVolumeAttachmentManager(clientIn client.SessionClient) VolumeAttachManager <span class="cov8" title="1">{
        err := models.IksError{}
        return &amp;IKSVolumeAttachService{
                client:        clientIn,
                pathPrefix:    IksPathPrefix,
                receiverError: &amp;err,
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package riaas ...
package riaas

import (
        "context"
        "io"
        "net/http"
)

// Config for the Session
type Config struct {
        BaseURL       string
        AccountID     string
        Username      string
        APIKey        string
        ResourceGroup string
        Password      string
        ContextID     string

        DebugWriter   io.Writer
        HTTPClient    *http.Client
        Context       context.Context
        APIVersion    string
        APIGeneration int
}

func (c Config) httpClient() *http.Client <span class="cov8" title="1">{
        if c.HTTPClient != nil </span><span class="cov8" title="1">{
                return c.HTTPClient
        }</span>

        <span class="cov8" title="1">return http.DefaultClient</span>
}

func (c Config) baseURL() string <span class="cov8" title="1">{
        return c.BaseURL
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package riaas ...
package riaas

import (
        "context"
        "net/url"
        "strconv"

        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/instances"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/vpcvolume"
)

// RegionalAPI is the main interface for the RIAAS API client. From here, service
// objects for the individual parts of the API can be obtained
//go:generate counterfeiter -o fakes/regional_api.go --fake-name RegionalAPI . RegionalAPI
type RegionalAPI interface {
        Login(token string) error

        VolumeService() vpcvolume.VolumeManager
        VolumeAttachService() instances.VolumeAttachManager
        IKSVolumeAttachService() instances.VolumeAttachManager
        SnapshotService() vpcvolume.SnapshotManager
}

var _ RegionalAPI = &amp;Session{}

// Session is a base implementation of the RegionalAPI interface
type Session struct {
        client client.SessionClient
        config Config
}

// New creates a new Session volume, using the supplied config
func New(config Config) (*Session, error) <span class="cov8" title="1">{
        ctx := config.Context
        if ctx == nil </span><span class="cov8" title="1">{
                ctx = context.Background()
        }</span>

        // Default API version
        <span class="cov8" title="1">backendAPIVersion := models.APIVersion

        // Overwrite if the version is passed
        if len(config.APIVersion) &gt; 0 </span><span class="cov8" title="1">{
                backendAPIVersion = config.APIVersion
        }</span>

        // Overwrite if the generation is passed
        <span class="cov8" title="1">apiGen := models.APIGeneration
        if config.APIGeneration &gt; 0 </span><span class="cov8" title="1">{
                apiGen = config.APIGeneration
        }</span>

        <span class="cov8" title="1">queryValues := url.Values{
                "version":    []string{backendAPIVersion},
                "generation": []string{strconv.Itoa(apiGen)},
        }

        riaasClient := client.New(ctx, config.baseURL(), queryValues, config.httpClient(), config.ContextID, config.ResourceGroup)

        if config.DebugWriter != nil </span><span class="cov8" title="1">{
                riaasClient.WithDebug(config.DebugWriter)
        }</span>
        <span class="cov8" title="1">return &amp;Session{
                client: riaasClient,
                config: config,
        }, nil</span>
}

// Login configures the session with the supplied Authentication token
// which is used for all requests to the API
func (s *Session) Login(token string) error <span class="cov8" title="1">{
        s.client.WithAuthToken(token)
        return nil
}</span>

// VolumeService returns the Volume service for managing volumes
func (s *Session) VolumeService() vpcvolume.VolumeManager <span class="cov8" title="1">{
        return vpcvolume.New(s.client)
}</span>

// VolumeAttachService returns the VolumeAttachService for managing volumes
func (s *Session) VolumeAttachService() instances.VolumeAttachManager <span class="cov8" title="1">{
        return instances.New(s.client)
}</span>

// IKSVolumeAttachService returns the VolumeAttachService for managing volumes through IKS
func (s *Session) IKSVolumeAttachService() instances.VolumeAttachManager <span class="cov0" title="0">{
        return instances.NewIKSVolumeAttachmentManager(s.client)
}</span>

// SnapshotService returns the Snapshot service for managing snapshot
func (s *Session) SnapshotService() vpcvolume.SnapshotManager <span class="cov8" title="1">{
        return vpcvolume.NewSnapshotManager(s.client)
}</span>

// RegionalAPIClientProvider declares an interface for a provider that can supply a new
// RegionalAPI client session
//go:generate counterfeiter -o fakes/client_provider.go --fake-name RegionalAPIClientProvider . RegionalAPIClientProvider
type RegionalAPIClientProvider interface {
        New(config Config) (RegionalAPI, error)
}

// DefaultRegionalAPIClientProvider declares a basic client provider that delegates to
// New(). Can be used for dependency injection.
type DefaultRegionalAPIClientProvider struct {
}

var _ RegionalAPIClientProvider = DefaultRegionalAPIClientProvider{}

// New creates a new Session volume, using the supplied config
func (d DefaultRegionalAPIClientProvider) New(config Config) (RegionalAPI, error) <span class="cov8" title="1">{
        return New(config)
}</span>

// IKSSession ...
type IKSSession struct {
        Session
}

var _ RegionalAPI = &amp;IKSSession{}

// VolumeService returns the Volume service for managing volumes
func (s *IKSSession) VolumeService() vpcvolume.VolumeManager <span class="cov0" title="0">{
        return vpcvolume.NewIKSVolumeService(s.client)
}</span>

//IKSRegionalAPIClientProvider ...
type IKSRegionalAPIClientProvider struct {
        RegionalAPIClientProvider
}

var _ RegionalAPIClientProvider = IKSRegionalAPIClientProvider{}

// New creates a new Session , using the supplied config
func (d IKSRegionalAPIClientProvider) New(config Config) (RegionalAPI, error) <span class="cov0" title="0">{
        session, err := New(config)
        if err != nil || session == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">iksSession := &amp;IKSSession{
                Session: *session,
        }
        return iksSession, err</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// CheckSnapshotTag checks if the given tag exists on a snapshot
func (ss *SnapshotService) CheckSnapshotTag(volumeID string, snapshotID string, tagName string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend CreateSnapshotTag")
        defer ctxLogger.Debug("Exit Backend CreateSnapshotTag")

        defer util.TimeTracker("CheckSnapshotTag", time.Now())

        operation := &amp;client.Operation{
                Name:        "CheckSnapshotTag",
                Method:      "GET",
                PathPattern: snapshotTagNamePath,
        }

        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()))

        req := request.PathParameter(volumeIDParam, volumeID).PathParameter(snapshotIDParam, snapshotID).PathParameter(snapshotTagParam, tagName).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// CheckVolumeTag checks if the given tag exists on a volume
func (vs *VolumeService) CheckVolumeTag(volumeID string, tagName string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend CheckVolumeTag")
        defer ctxLogger.Debug("Exit Backend CheckVolumeTag")

        defer util.TimeTracker("CheckVolumeTag", time.Now())

        operation := &amp;client.Operation{
                Name:        "CheckVolumeTag",
                Method:      "GET",
                PathPattern: volumeTagNamePath,
        }

        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID).PathParameter(volumeTagParam, tagName).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// CreateSnapshot POSTs to /snapshots
func (ss *SnapshotService) CreateSnapshot(snapshotTemplate *models.Snapshot, ctxLogger *zap.Logger) (*models.Snapshot, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend CreateSpanShot")
        defer ctxLogger.Debug("Exit Backend CreateSnapshot")

        defer util.TimeTracker("CreateSnapshot", time.Now())

        operation := &amp;client.Operation{
                Name:        "CreateSnapshot",
                Method:      "POST",
                PathPattern: snapshotsPath,
        }

        var snapshot models.Snapshot
        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", request.URL()), zap.Reflect("Payload", snapshotTemplate), zap.Reflect("Operation", operation))

        _, err := request.JSONBody(snapshotTemplate).JSONSuccess(&amp;snapshot).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;snapshot, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// CreateVolume POSTs to /volumes
func (vs *VolumeService) CreateVolume(volumeTemplate *models.Volume, ctxLogger *zap.Logger) (*models.Volume, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend CreateVolume")
        defer ctxLogger.Debug("Exit Backend CreateVolume")

        defer util.TimeTracker("CreateVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "CreateVolume",
                Method:      "POST",
                PathPattern: volumesPath,
        }

        var volume models.Volume
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", request.URL()), zap.Reflect("Payload", volumeTemplate), zap.Reflect("Operation", operation))

        _, err := request.JSONBody(volumeTemplate).JSONSuccess(&amp;volume).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;volume, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DeleteSnapshot DELETEs to /snapshots
func (ss *SnapshotService) DeleteSnapshot(snapshotID string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend DeleteSpanshot")
        defer ctxLogger.Debug("Exit Backend DeleteSnapshot")

        defer util.TimeTracker("DeleteSnapshot", time.Now())

        operation := &amp;client.Operation{
                Name:        "DeleteSnapshot",
                Method:      "DELETE",
                PathPattern: snapshotIDPath,
        }

        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        _, err := request.PathParameter(snapshotIDParam, snapshotID).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DeleteSnapshotTag deletes tag of a snapshot
func (ss *SnapshotService) DeleteSnapshotTag(volumeID string, snapshotID string, tagName string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend DeleteSnapshotTag")
        defer ctxLogger.Debug("Exit Backend DeleteSnapshotTag")

        defer util.TimeTracker("DeleteSnapshotTag", time.Now())

        operation := &amp;client.Operation{
                Name:        "DeleteSnapshotTag",
                Method:      "DELETE",
                PathPattern: snapshotTagNamePath,
        }

        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID).PathParameter(snapshotIDParam, snapshotID).PathParameter(snapshotTagParam, tagName).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DeleteVolume POSTs to /volumes
func (vs *VolumeService) DeleteVolume(volumeID string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend DeleteVolume")
        defer ctxLogger.Debug("Exit Backend DeleteVolume")

        defer util.TimeTracker("DeleteVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "DeleteVolume",
                Method:      "DELETE",
                PathPattern: volumeIDPath,
        }

        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        _, err := request.PathParameter(volumeIDParam, volumeID).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// DeleteVolumeTag deletes tag of a volume
func (vs *VolumeService) DeleteVolumeTag(volumeID string, tagName string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend DeleteVolumeTag")
        defer ctxLogger.Debug("Exit Backend DeleteVolumeTag")

        defer util.TimeTracker("DeleteVolumeTag", time.Now())

        operation := &amp;client.Operation{
                Name:        "DeleteVolumeTag",
                Method:      "DELETE",
                PathPattern: volumeTagNamePath,
        }

        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID).PathParameter(volumeTagParam, tagName).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/**
 * Copyright 2021 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ExpandVolume PATCH to /volumes
func (vs *VolumeService) ExpandVolume(volumeID string, volumeTemplate *models.Volume, ctxLogger *zap.Logger) (*models.Volume, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ExpandVolume")
        defer ctxLogger.Debug("Exit Backend ExpandVolume")

        defer util.TimeTracker("ExpandVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "ExpandVolume",
                Method:      "PATCH",
                PathPattern: volumeIDPath,
        }

        var volume models.Volume
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        req := request.PathParameter(volumeIDParam, volumeID)
        ctxLogger.Info("Equivalent curl command and payload details", zap.Reflect("URL", req.URL()), zap.Reflect("Payload", volumeTemplate), zap.Reflect("Operation", operation))
        _, err := req.JSONBody(volumeTemplate).JSONSuccess(&amp;volume).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;volume, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GetSnapshot GETs from /snapshots
func (ss *SnapshotService) GetSnapshot(snapshotID string, ctxLogger *zap.Logger) (*models.Snapshot, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetSnapshot")
        defer ctxLogger.Debug("Exit Backend GetSnapshot")

        defer util.TimeTracker("GetSnapshot", time.Now())

        operation := &amp;client.Operation{
                Name:        "GetSnapshot",
                Method:      "GET",
                PathPattern: snapshotIDPath,
        }

        var snapshot models.Snapshot
        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(snapshotIDParam, snapshotID)

        _, err := req.JSONSuccess(&amp;snapshot).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;snapshot, nil</span>
}

// GetSnapshotByName GETs /snapshots
func (ss *SnapshotService) GetSnapshotByName(snapshotName string, ctxLogger *zap.Logger) (*models.Snapshot, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetSnapshotByName")
        defer ctxLogger.Debug("Exit Backend GetSnapshotByName")

        defer util.TimeTracker("GetSnapshotByName", time.Now())

        // Get the snapshot details for a single snapshot, ListSnapshotFilters will return only 1 snapshot in list
        filters := &amp;models.LisSnapshotFilters{Name: snapshotName}
        snapshots, err := ss.ListSnapshots(1, "", filters, ctxLogger)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if snapshots != nil </span><span class="cov8" title="1">{
                snapshotlist := snapshots.Snapshots
                if len(snapshotlist) &gt; 0 </span><span class="cov8" title="1">{
                        return snapshotlist[0], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// GetVolume POSTs to /volumes
func (vs *VolumeService) GetVolume(volumeID string, ctxLogger *zap.Logger) (*models.Volume, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetVolume")
        defer ctxLogger.Debug("Exit Backend GetVolume")

        defer util.TimeTracker("GetVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "GetVolume",
                Method:      "GET",
                PathPattern: volumeIDPath,
        }

        var volume models.Volume
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID)
        _, err := req.JSONSuccess(&amp;volume).JSONError(&amp;apiErr).Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;volume, nil</span>
}

// GetVolumeByName GETs /volumes
func (vs *VolumeService) GetVolumeByName(volumeName string, ctxLogger *zap.Logger) (*models.Volume, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend GetVolumeByName")
        defer ctxLogger.Debug("Exit Backend GetVolumeByName")

        defer util.TimeTracker("GetVolumeByName", time.Now())

        // Get the volume details for a single volume, ListVolumeFilters will return only 1 volume in list
        filters := &amp;models.ListVolumeFilters{VolumeName: volumeName}
        volumes, err := vs.ListVolumes(1, "", filters, ctxLogger)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if volumes != nil </span><span class="cov8" title="1">{
                volumeslist := volumes.Volumes
                if len(volumeslist) &gt; 0 </span><span class="cov8" title="1">{
                        return volumeslist[0], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// UpdateVolume POSTs to /volumes
func (vs *IKSVolumeService) UpdateVolume(volumeTemplate *models.Volume, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend IKSVolumeService.UpdateVolume")
        defer ctxLogger.Debug("Exit Backend IKSVolumeService.UpdateVolume")

        defer util.TimeTracker("IKSVolumeService.UpdateVolume", time.Now())

        operation := &amp;client.Operation{
                Name:        "UpdateVolume",
                Method:      "POST",
                PathPattern: vs.pathPrefix + updateVolume,
        }
        apiErr := vs.receiverError
        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation), zap.Reflect("volumeTemplate", volumeTemplate))

        _, err := request.JSONBody(volumeTemplate).JSONError(apiErr).Invoke()
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Update volume failed with error", zap.Error(err), zap.Error(apiErr))
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
)

const (
        //IksV2PathPrefix ...
        IksV2PathPrefix = "v2/storage/"
)

// IKSVolumeService ...
type IKSVolumeService struct {
        VolumeService
        pathPrefix    string
        receiverError error
}

var _ VolumeManager = &amp;IKSVolumeService{}

// NewIKSVolumeService ...
func NewIKSVolumeService(client client.SessionClient) VolumeManager <span class="cov8" title="1">{
        err := models.IksError{}
        iksVolumeService := &amp;IKSVolumeService{
                VolumeService: VolumeService{
                        client: client,
                },
                pathPrefix:    IksV2PathPrefix,
                receiverError: &amp;err,
        }
        return iksVolumeService
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ListSnapshotTags GETs /volumes/snapshots/tags
func (ss *SnapshotService) ListSnapshotTags(volumeID string, snapshotID string, ctxLogger *zap.Logger) (*[]string, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListSnapshotTags")
        defer ctxLogger.Debug("Exit Backend ListSnapshotTags")

        defer util.TimeTracker("ListSnapshotTags", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListSnapshotTags",
                Method:      "GET",
                PathPattern: snapshotTagsPath,
        }

        var tags []string
        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID).PathParameter(snapshotIDParam, snapshotID).JSONSuccess(&amp;tags).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tags, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "strconv"
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ListSnapshots GETs /snapshots
func (ss *SnapshotService) ListSnapshots(limit int, start string, filters *models.LisSnapshotFilters, ctxLogger *zap.Logger) (*models.SnapshotList, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListSnapshots")
        defer ctxLogger.Debug("Exit Backend ListSnapshots")

        defer util.TimeTracker("ListSnapshots", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListSnapshots",
                Method:      "GET",
                PathPattern: snapshotsPath,
        }

        var snapshots models.SnapshotList
        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.JSONSuccess(&amp;snapshots).JSONError(&amp;apiErr)

        if limit &gt; 0 </span><span class="cov8" title="1">{
                req.AddQueryValue("limit", strconv.Itoa(limit))
        }</span>

        <span class="cov8" title="1">if start != "" </span><span class="cov8" title="1">{
                req.AddQueryValue("start", start)
        }</span>

        <span class="cov8" title="1">if filters != nil </span><span class="cov8" title="1">{
                if filters.ResourceGroupID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("resource_group.id", filters.ResourceGroupID)
                }</span>
                <span class="cov8" title="1">if filters.Name != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("name", filters.Name)
                }</span>
                <span class="cov8" title="1">if filters.SourceVolumeID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("source_volume.id", filters.SourceVolumeID)
                }</span>
        }

        <span class="cov8" title="1">_, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;snapshots, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ListVolumeTags GETs /volumes/tags
func (vs *VolumeService) ListVolumeTags(volumeID string, ctxLogger *zap.Logger) (*[]string, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListVolumeTags")
        defer ctxLogger.Debug("Exit Backend ListVolumeTags")

        defer util.TimeTracker("ListVolumeTags", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListVolumeTags",
                Method:      "GET",
                PathPattern: volumeTagsPath,
        }

        var tags []string
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID).JSONSuccess(&amp;tags).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tags, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "strconv"
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// ListVolumes GETs /volumes
func (vs *VolumeService) ListVolumes(limit int, start string, filters *models.ListVolumeFilters, ctxLogger *zap.Logger) (*models.VolumeList, error) <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend ListVolumes")
        defer ctxLogger.Debug("Exit Backend ListVolumes")

        defer util.TimeTracker("ListVolumes", time.Now())

        operation := &amp;client.Operation{
                Name:        "ListVolumes",
                Method:      "GET",
                PathPattern: volumesPath,
        }

        var volumes models.VolumeList
        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.JSONSuccess(&amp;volumes).JSONError(&amp;apiErr)

        if limit &gt; 0 </span><span class="cov8" title="1">{
                req.AddQueryValue("limit", strconv.Itoa(limit))
        }</span>

        <span class="cov8" title="1">if start != "" </span><span class="cov8" title="1">{
                req.AddQueryValue("start", start)
        }</span>

        <span class="cov8" title="1">if filters != nil </span><span class="cov8" title="1">{
                if filters.ResourceGroupID != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("resource_group.id", filters.ResourceGroupID)
                }</span>
                <span class="cov8" title="1">if filters.Tag != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("tag", filters.Tag)
                }</span>
                <span class="cov8" title="1">if filters.ZoneName != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("zone.name", filters.ZoneName)
                }</span>
                <span class="cov8" title="1">if filters.VolumeName != "" </span><span class="cov8" title="1">{
                        req.AddQueryValue("name", filters.VolumeName)
                }</span>
        }

        <span class="cov8" title="1">_, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;volumes, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// SetSnapshotTag sets tag for a snapshot
func (ss *SnapshotService) SetSnapshotTag(volumeID string, snapshotID string, tagName string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend SetVolumeTag")
        defer ctxLogger.Debug("Exit Backend SetVolumeTag")

        defer util.TimeTracker("SetSnapshotTag", time.Now())

        operation := &amp;client.Operation{
                Name:        "SetSnapshotTag",
                Method:      "PUT",
                PathPattern: snapshotTagNamePath,
        }

        var apiErr models.Error

        request := ss.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID).PathParameter(snapshotIDParam, snapshotID).PathParameter(snapshotTagParam, tagName).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "time"

        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// SetVolumeTag sets tag for a volume
func (vs *VolumeService) SetVolumeTag(volumeID string, tagName string, ctxLogger *zap.Logger) error <span class="cov8" title="1">{
        ctxLogger.Debug("Entry Backend SetVolumeTag")
        defer ctxLogger.Debug("Exit Backend SetVolumeTag")

        defer util.TimeTracker("SetVolumeTag", time.Now())

        operation := &amp;client.Operation{
                Name:        "SetVolumeTag",
                Method:      "PUT",
                PathPattern: volumeTagNamePath,
        }

        var apiErr models.Error

        request := vs.client.NewRequest(operation)
        ctxLogger.Info("Equivalent curl command", zap.Reflect("URL", request.URL()), zap.Reflect("Operation", operation))

        req := request.PathParameter(volumeIDParam, volumeID).PathParameter(volumeTagParam, tagName).JSONError(&amp;apiErr)
        _, err := req.Invoke()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// SnapshotManager operations
type SnapshotManager interface {
        // Create the snapshot on the volume
        CreateSnapshot(snapshotTemplate *models.Snapshot, ctxLogger *zap.Logger) (*models.Snapshot, error)

        // Delete the snapshot
        DeleteSnapshot(snapshotID string, ctxLogger *zap.Logger) error

        // Get the snapshot
        GetSnapshot(snapshotID string, ctxLogger *zap.Logger) (*models.Snapshot, error)

        // Get the snapshot by using snapshot name
        GetSnapshotByName(snapshotName string, ctxLogger *zap.Logger) (*models.Snapshot, error)

        // List all the  snapshots for a given volume
        ListSnapshots(limit int, start string, filters *models.LisSnapshotFilters, ctxLogger *zap.Logger) (*models.SnapshotList, error)

        // Set tag for a snapshot
        SetSnapshotTag(volumeID string, snapshotID string, tagName string, ctxLogger *zap.Logger) error

        // Delete tag of a snapshot
        DeleteSnapshotTag(volumeID string, snapshotID string, tagName string, ctxLogger *zap.Logger) error

        // List all tags of a snapshot
        ListSnapshotTags(volumeID string, snapshotID string, ctxLogger *zap.Logger) (*[]string, error)

        // Check if the given tag exists on a snapshot
        CheckSnapshotTag(volumeID string, snapshotID string, tagName string, ctxLogger *zap.Logger) error
}

// SnapshotService ...
type SnapshotService struct {
        client client.SessionClient
}

var _ SnapshotManager = &amp;SnapshotService{}

// NewSnapshotManager ...
func NewSnapshotManager(client client.SessionClient) SnapshotManager <span class="cov8" title="1">{
        return &amp;SnapshotService{
                client: client,
        }
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "errors"

        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// UpdateVolume POSTs to /volumes. Riaas/VPC does have volume update support yet
func (vs *VolumeService) UpdateVolume(volumeTemplate *models.Volume, ctxLogger *zap.Logger) error <span class="cov0" title="0">{
        return errors.New("unsupported Operation")
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package vpcvolume ...
package vpcvolume

import (
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/client"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// VolumeManager operations
type VolumeManager interface {
        // Create the volume with authorisation by passing required information in the volume object
        CreateVolume(volumeTemplate *models.Volume, ctxLogger *zap.Logger) (*models.Volume, error)
        // UpdateVolume updates the volume with authorisation by passing required information in the volume object
        UpdateVolume(volumeTemplate *models.Volume, ctxLogger *zap.Logger) error

        // ExpandVolume ...
        ExpandVolume(volumeID string, volumeTemplate *models.Volume, ctxLogger *zap.Logger) (*models.Volume, error)

        // Delete the volume
        DeleteVolume(volumeID string, ctxLogger *zap.Logger) error

        // Get the volume by using ID
        GetVolume(volumeID string, ctxLogger *zap.Logger) (*models.Volume, error)

        // Get the volume by using volume name
        GetVolumeByName(volumeName string, ctxLogger *zap.Logger) (*models.Volume, error)

        // Others
        // Get volume lists by using snapshot tags
        ListVolumes(limit int, start string, filters *models.ListVolumeFilters, ctxLogger *zap.Logger) (*models.VolumeList, error)

        // Set tag for a volume
        SetVolumeTag(volumeID string, tagName string, ctxLogger *zap.Logger) error

        // Delete tag of a volume
        DeleteVolumeTag(volumeID string, tagName string, ctxLogger *zap.Logger) error

        // List all tags of a volume
        ListVolumeTags(volumeID string, ctxLogger *zap.Logger) (*[]string, error)

        // Check if the given tag exists on a volume
        CheckVolumeTag(volumeID string, tagName string, ctxLogger *zap.Logger) error
}

// VolumeService ...
type VolumeService struct {
        client client.SessionClient
}

var _ VolumeManager = &amp;VolumeService{}

// New ...
func New(client client.SessionClient) VolumeManager <span class="cov8" title="1">{
        return &amp;VolumeService{
                client: client,
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "context"
        "errors"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
        utilReasonCode "github.com/IBM/ibmcloud-volume-interface/lib/utils/reasoncode"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
        vpcprovider "github.com/IBM/ibmcloud-volume-vpc/block/provider"
        vpcconfig "github.com/IBM/ibmcloud-volume-vpc/block/vpcconfig"
        vpcauth "github.com/IBM/ibmcloud-volume-vpc/common/auth"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/riaas"

        "go.uber.org/zap"
)

//IksVpcBlockProvider  handles both IKS and  RIAAS sessions
type IksVpcBlockProvider struct {
        vpcprovider.VPCBlockProvider
        vpcBlockProvider *vpcprovider.VPCBlockProvider // Holds VPC provider. Requires to avoid recursive calls
        iksBlockProvider *vpcprovider.VPCBlockProvider // Holds IKS provider
}

var _ local.Provider = &amp;IksVpcBlockProvider{}

//NewProvider handles both IKS and  RIAAS sessions
func NewProvider(conf *vpcconfig.VPCBlockConfig, logger *zap.Logger) (local.Provider, error) <span class="cov8" title="1">{
        //Setup vpc provider
        provider, _ := vpcprovider.NewProvider(conf, logger)
        vpcBlockProvider, _ := provider.(*vpcprovider.VPCBlockProvider)
        // Setup IKS provider
        provider, _ = vpcprovider.NewProvider(conf, logger)
        iksBlockProvider, _ := provider.(*vpcprovider.VPCBlockProvider)

        //Overrider Base URL
        iksBlockProvider.APIConfig.BaseURL = conf.VPCConfig.IKSTokenExchangePrivateURL
        // Setup IKS-VPC dual provider
        iksVpcBlockProvider := &amp;IksVpcBlockProvider{
                VPCBlockProvider: *vpcBlockProvider,
                vpcBlockProvider: vpcBlockProvider,
                iksBlockProvider: iksBlockProvider,
        }

        //vpcBlockProvider.ApiConfig.BaseURL = conf.VPC.IKSTokenExchangePrivateURL
        return iksVpcBlockProvider, nil
}</span>

// OpenSession opens a session on the provider
func (iksp *IksVpcBlockProvider) OpenSession(ctx context.Context, contextCredentials provider.ContextCredentials, ctxLogger *zap.Logger) (provider.Session, error) <span class="cov8" title="1">{
        ctxLogger.Info("Entering IksVpcBlockProvider.OpenSession")

        defer func() </span><span class="cov8" title="1">{
                ctxLogger.Debug("Exiting IksVpcBlockProvider.OpenSession")
        }</span>()
        <span class="cov8" title="1">ctxLogger.Info("Opening VPC block session")
        ccf, _ := iksp.vpcBlockProvider.ContextCredentialsFactory(nil)
        ctxLogger.Info("Its IKS dual session. Getttng IAM token for  VPC block session")
        vpcContextCredentials, err := ccf.ForIAMAccessToken(iksp.iksBlockProvider.Config.VPCConfig.APIKey, ctxLogger)
        if err != nil </span><span class="cov8" title="1">{
                ctxLogger.Error("Error occurred while generating IAM token for VPC", zap.Error(err))
                if util.ErrorReasonCode(err) == utilReasonCode.EndpointNotReachable </span><span class="cov0" title="0">{
                        userErr := userError.GetUserError(string(userError.EndpointNotReachable), err)
                        return nil, userErr
                }</span>
                <span class="cov8" title="1">if util.ErrorReasonCode(err) == utilReasonCode.Timeout </span><span class="cov0" title="0">{
                        userErr := userError.GetUserError(string(userError.Timeout), err)
                        return nil, userErr
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov0" title="0">session, err := iksp.vpcBlockProvider.OpenSession(ctx, vpcContextCredentials, ctxLogger)
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error occurred while opening VPCSession", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">vpcSession, _ := session.(*vpcprovider.VPCSession)
        ctxLogger.Info("Opening IKS block session")

        //Create ContextCredentialsFactory
        ccf, err = iksp.ContextCredentialsFactory(nil)
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Error("Error while creating the ContextCredentialsFactory", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">iksp.iksBlockProvider.ContextCF = ccf
        iksp.iksBlockProvider.ClientProvider = riaas.IKSRegionalAPIClientProvider{}

        ctxLogger.Info("Its ISK dual session. Getttng IAM token for  IKS block session")
        iksContextCredentials, err := ccf.ForIAMAccessToken(iksp.iksBlockProvider.Config.VPCConfig.APIKey, ctxLogger)
        if err != nil </span><span class="cov0" title="0">{
                ctxLogger.Warn("Error occurred while generating IAM token for IKS. But continue with VPC session alone. \n Volume Mount operation will fail but volume provisioning will work", zap.Error(err))
                session = &amp;vpcprovider.VPCSession{
                        Logger:       ctxLogger,
                        SessionError: err,
                } // Empty session to avoid Nil references.
        }</span> else<span class="cov0" title="0"> {
                session, err = iksp.iksBlockProvider.OpenSession(ctx, iksContextCredentials, ctxLogger)
                if err != nil </span><span class="cov0" title="0">{
                        ctxLogger.Error("Error occurred while opening IKSSession", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">iksSession, ok := session.(*vpcprovider.VPCSession)
        if ok &amp;&amp; iksSession.Apiclient != nil </span><span class="cov0" title="0">{
                iksSession.APIClientVolAttachMgr = iksSession.Apiclient.IKSVolumeAttachService()
        }</span>
        // Setup Dual Session that handles for VPC and IKS connections
        <span class="cov0" title="0">vpcIksSession := IksVpcSession{
                VPCSession: *vpcSession,
                IksSession: iksSession,
        }
        ctxLogger.Debug("IksVpcSession", zap.Reflect("IksVpcSession", vpcIksSession))
        return &amp;vpcIksSession, nil</span>
}

// ContextCredentialsFactory ...
func (iksp *IksVpcBlockProvider) ContextCredentialsFactory(zone *string) (local.ContextCredentialsFactory, error) <span class="cov8" title="1">{
        return vpcauth.NewVPCContextCredentialsFactory(iksp.vpcBlockProvider.Config)
}</span>

// UpdateAPIKey ...
func (iksp *IksVpcBlockProvider) UpdateAPIKey(conf interface{}, logger *zap.Logger) error <span class="cov8" title="1">{
        logger.Info("Updating api key in iks vpc provider")
        vpcConfig, ok := conf.(*vpcconfig.VPCBlockConfig)
        if !ok </span><span class="cov8" title="1">{
                logger.Error("Error fetching vpc block config from interface")
                return errors.New("error unmarshaling vpc block config")
        }</span>
        <span class="cov8" title="1">if iksp.vpcBlockProvider == nil </span><span class="cov0" title="0">{
                logger.Error("VPC Block provider not initialized, hence unable to update api key")
                return errors.New("vpc block provider not initialized")
        }</span>
        <span class="cov8" title="1">err := iksp.vpcBlockProvider.UpdateAPIKey(vpcConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error updating api key in vpc block provider", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">err = iksp.iksBlockProvider.UpdateAPIKey(vpcConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error updating api key in iks block provider", zap.Error(err))
                return err
        }</span>

        <span class="cov8" title="1">iksp.VPCBlockProvider = *iksp.vpcBlockProvider
        return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "net/http"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        vpcprovider "github.com/IBM/ibmcloud-volume-vpc/block/provider"
)

// IksVpcSession implements lib.Session for VPC IKS dual session
type IksVpcSession struct {
        vpcprovider.VPCSession                         // Holds VPC/Riaas session by default
        IksSession             *vpcprovider.VPCSession // Holds IKS session
}

var _ provider.Session = &amp;IksVpcSession{}

const (
        // Provider storage provider
        Provider = provider.VolumeProvider("IKS-VPC-Block")
        // VolumeType ...
        VolumeType = provider.VolumeType("VPC-Block")
)

// Close at present does nothing
func (vpcIks *IksVpcSession) Close() {<span class="cov8" title="1">
        // Do nothing for now
}</span>

// GetProviderDisplayName returns the name of the VPC provider
func (vpcIks *IksVpcSession) GetProviderDisplayName() provider.VolumeProvider <span class="cov8" title="1">{
        return Provider
}</span>

// ProviderName ...
func (vpcIks *IksVpcSession) ProviderName() provider.VolumeProvider <span class="cov8" title="1">{
        return Provider
}</span>

// Type ...
func (vpcIks *IksVpcSession) Type() provider.VolumeType <span class="cov8" title="1">{
        return VolumeType
}</span>

// AttachVolume attach volume based on given volume attachment request
func (vpcIks *IksVpcSession) AttachVolume(volumeAttachmentRequest provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) <span class="cov0" title="0">{
        vpcIks.Logger.Debug("Entry of IksVpcSession.AttachVolume method...")
        defer vpcIks.Logger.Debug("Exit from IksVpcSession.AttachVolume method...")
        return vpcIks.IksSession.AttachVolume(volumeAttachmentRequest)
}</span>

// DetachVolume attach volume based on given volume attachment request
func (vpcIks *IksVpcSession) DetachVolume(volumeAttachmentRequest provider.VolumeAttachmentRequest) (*http.Response, error) <span class="cov0" title="0">{
        vpcIks.IksSession.Logger.Debug("Entry of IksVpcSession.DetachVolume method...")
        defer vpcIks.Logger.Debug("Exit from IksVpcSession.DetachVolume method...")
        return vpcIks.IksSession.DetachVolume(volumeAttachmentRequest)
}</span>

// GetVolumeAttachment attach volume based on given volume attachment request
func (vpcIks *IksVpcSession) GetVolumeAttachment(volumeAttachmentRequest provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) <span class="cov0" title="0">{
        vpcIks.Logger.Debug("Entry of IksVpcSession.GetVolumeAttachment method...")
        defer vpcIks.Logger.Debug("Exit from IksVpcSession.GetVolumeAttachment method...")
        return vpcIks.IksSession.GetVolumeAttachment(volumeAttachmentRequest)
}</span>

// WaitForAttachVolume attach volume based on given volume attachment request
func (vpcIks *IksVpcSession) WaitForAttachVolume(volumeAttachmentRequest provider.VolumeAttachmentRequest) (*provider.VolumeAttachmentResponse, error) <span class="cov0" title="0">{
        vpcIks.Logger.Debug("Entry of IksVpcSession.WaitForAttachVolume method...")
        defer vpcIks.Logger.Debug("Exit from IksVpcSession.WaitForAttachVolume method...")
        return vpcIks.IksSession.WaitForAttachVolume(volumeAttachmentRequest)
}</span>

// WaitForDetachVolume attach volume based on given volume attachment request
func (vpcIks *IksVpcSession) WaitForDetachVolume(volumeAttachmentRequest provider.VolumeAttachmentRequest) error <span class="cov0" title="0">{
        vpcIks.Logger.Debug("Entry of IksVpcSession.WaitForDetachVolume method...")
        defer vpcIks.Logger.Debug("Exit from IksVpcSession.WaitForDetachVolume method...")
        return vpcIks.IksSession.WaitForDetachVolume(volumeAttachmentRequest)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package provider ...
package provider

import (
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/metrics"
        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        vpc_provider "github.com/IBM/ibmcloud-volume-vpc/block/provider"
        userError "github.com/IBM/ibmcloud-volume-vpc/common/messages"
        "github.com/IBM/ibmcloud-volume-vpc/common/vpcclient/models"
        "go.uber.org/zap"
)

// UpdateVolume updates the volume with given information
func (vpcIks *IksVpcSession) UpdateVolume(volumeRequest provider.Volume) (err error) <span class="cov8" title="1">{
        vpcIks.Logger.Debug("Entry of UpdateVolume method...")
        defer vpcIks.Logger.Debug("Exit from UpdateVolume method...")
        defer metrics.UpdateDurationFromStart(vpcIks.Logger, "UpdateVolume", time.Now())

        vpcIks.Logger.Info("Basic validation for UpdateVolume request... ", zap.Reflect("RequestedVolumeDetails", volumeRequest))

        // Build the template to send to backend
        volumeTemplate := models.NewVolume(volumeRequest)
        err = validateVolumeRequest(volumeRequest)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">vpcIks.Logger.Info("Successfully validated inputs for UpdateVolume request... ")

        vpcIks.Logger.Info("Calling  provider for volume update...")
        err = vpcIks.APIRetry.FlexyRetry(vpcIks.Logger, func() (error, bool) </span><span class="cov8" title="1">{
                err = vpcIks.IksSession.Apiclient.VolumeService().UpdateVolume(&amp;volumeTemplate, vpcIks.Logger)
                return err, err == nil || vpc_provider.SkipRetryForIKS(err)
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                vpcIks.Logger.Debug("Failed to update volume", zap.Reflect("BackendError", err))
                return userError.GetUserError("UpdateFailed", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// validateVolumeRequest validating volume request
func validateVolumeRequest(volumeRequest provider.Volume) error <span class="cov8" title="1">{
        // Volume name should not be empty
        if len(volumeRequest.VolumeID) == 0 </span><span class="cov8" title="1">{
                return userError.GetUserError("ErrorRequiredFieldMissing", nil, "VolumeID")
        }</span>
        // Provider name should not be empty
        <span class="cov8" title="1">if len(volumeRequest.Provider) == 0 </span><span class="cov8" title="1">{
                return userError.GetUserError("ErrorRequiredFieldMissing", nil, "Provider")
        }</span>
        // VolumeType  should not be empty
        <span class="cov8" title="1">if len(volumeRequest.VolumeType) == 0 </span><span class="cov0" title="0">{
                return userError.GetUserError("ErrorRequiredFieldMissing", nil, "VolumeType")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
